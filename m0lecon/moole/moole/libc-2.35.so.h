/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'libc-2.35.so'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct _Unwind_Exception;
struct spwd;
struct sgrp;
struct passwd;
struct etherent;
struct aliasent;
struct __netgrent;
struct __gconv_step;
struct cache_node;
struct AUTH;
struct servent;
struct protoent;
struct netent;
struct hostent;
struct group;
struct rpcent;
struct ether_addr;
struct audit_ifaces;
struct La_x86_64_retval;
struct La_x86_64_regs;
struct Elf64_Sym_0;
struct Elf32_Sym;
struct Dl_info;
struct dlfcn_hook;
struct link_map_reldeps;
struct reloc_result;
struct r_found_version;
struct libname_list;
struct r_search_path_elem;
struct Elf64_Dyn_0;
struct link_map;
struct Elf64_Phdr;
struct Elf64_Ehdr;
struct pthread_attr_extension;
struct unique_sym;
struct pthread_unwind_buf;
struct _pthread_cleanup_buffer;
struct list_head;
struct link_map_public;
struct siginfo_t;
struct name_list;
struct nss_module;
struct gaih_addrtuple;
struct rpc_err;
struct xdr_ops;
struct _IO_jump_t;
struct __mbstate_t;
struct __gconv_loaded_object;
struct _IO_wide_data;
struct _IO_codecvt;
struct _IO_FILE;
struct _IO_marker;
struct rpc_msg;
struct xp_ops;
struct proglst_;
struct svcraw_private_s;
struct svc_callout;
struct cache_entry;
struct key_call_private;
struct callrpc_private_s;
struct clntraw_private_s;
struct svc_req;
struct clnt_ops;
struct auth_ops;
struct resolv_conf;
struct resolv_sortlist_entry;
struct waitlist;
struct addrinfo;
struct HEADER;
struct era_entry;
struct gconv_fcts;
struct lc_time_data;
struct __locale_struct;
struct netlink_res;
struct unwind_link;
struct argp_child;
struct argp;
struct argp_option;
struct parser;
struct option;
struct hol_help_state;
struct hol_entry;
struct hol_cluster;
struct argp_fmtstream;
struct _IO_FILE_0;
struct _libc_fpstate;
struct stack_t;
struct tostruct;
struct shmid_ds;
struct seminfo;
struct semid_ds;
struct msqid_ds;
struct re_dfa_t;
struct node_t;
struct _ENTRY;
struct _ftsent;
struct dir_data;
struct posix_spawn_file_actions_t;
struct __spawn_action;
struct sort_result;
struct re_token_t;
struct re_pattern_buffer;
struct re_node_set;
struct re_state_table_entry;
struct re_fail_stack_ent_t;
struct re_sub_match_top_t;
struct re_backref_cache_entry;
struct re_sub_match_last_t;
struct state_array_t;
struct re_dfastate_t;
struct bin_tree_storage_t;
struct bin_tree_t;
struct re_charset_t;
struct fork_handler;
struct _obstack_chunk;
struct tcache_entry;
struct _heap_info;
union tunable_val_t;
struct inuse_sem;
union dtv;
struct _IO_strfile_;
struct _fpstate;
struct catalog_info;
struct catalog_obj;
struct converted_domain;
struct __gconv_info;
struct string_desc;
struct transmem_list;
union semun;
struct __once_flag;
struct fmemopen_cookie_struct;
struct _IO_cookie_io_functions_t;
struct dl_tls_index;
struct rec_strm;
struct __dirstream;
struct _G_fpos_t;

/* 1 */
struct __attribute__((aligned(8))) Elf64_Sym
{
  unsigned __int32 st_name;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  unsigned __int16 st_shndx;
  unsigned __int64 st_value;
  unsigned __int64 st_size;
};

/* 2 */
struct Elf64_Rela
{
  unsigned __int64 r_offset;
  unsigned __int64 r_info;
  __int64 r_addend;
};

/* 3 */
struct Elf64_Dyn
{
  unsigned __int64 d_tag;
  unsigned __int64 d_un;
};

/* 4 */
struct Elf64_Verdef
{
  unsigned __int16 vd_version;
  unsigned __int16 vd_flags;
  unsigned __int16 vd_ndx;
  unsigned __int16 vd_cnt;
  unsigned __int32 vd_hash;
  unsigned __int32 vd_aux;
  unsigned __int32 vd_next;
};

/* 5 */
struct __attribute__((aligned(4))) Elf64_Verdaux
{
  unsigned __int32 vda_name;
  unsigned __int32 vda_next;
};

/* 6 */
struct __attribute__((aligned(4))) Elf64_Verneed
{
  unsigned __int16 vn_version;
  unsigned __int16 vn_cnt;
  unsigned __int32 vn_file;
  unsigned __int32 vn_aux;
  unsigned __int32 vn_next;
};

/* 7 */
struct __attribute__((aligned(4))) Elf64_Vernaux
{
  unsigned __int32 vna_hash;
  unsigned __int16 vna_flags;
  unsigned __int16 vna_other;
  unsigned __int32 vna_name;
  unsigned __int32 vna_next;
};

/* 8 */
union __attribute__((aligned(16))) __m128i
{
  __int8 m128i_i8[16];
  __int16 m128i_i16[8];
  __int32 m128i_i32[4];
  __int64 m128i_i64[2];
  unsigned __int8 m128i_u8[16];
  unsigned __int16 m128i_u16[8];
  unsigned __int32 m128i_u32[4];
  unsigned __int64 m128i_u64[2];
};

/* 9 */
union __attribute__((aligned(8))) __m64
{
  unsigned __int64 m64_u64;
  float m64_f32[2];
  __int8 m64_i8[8];
  __int16 m64_i16[4];
  __int32 m64_i32[2];
  __int64 m64_i64;
  unsigned __int8 m64_u8[8];
  unsigned __int16 m64_u16[4];
  unsigned __int32 m64_u32[2];
};

/* 10 */
union __attribute__((aligned(16))) __m128
{
  float m128_f32[4];
  unsigned __int64 m128_u64[2];
  __int8 m128_i8[16];
  __int16 m128_i16[8];
  __int32 m128_i32[4];
  __int64 m128_i64[2];
  unsigned __int8 m128_u8[16];
  unsigned __int16 m128_u16[8];
  unsigned __int32 m128_u32[4];
};

/* 11 */
struct __m128d
{
  double m128d_f64[2];
};

/* 12 */
union __attribute__((aligned(32))) __m256
{
  float m256_f32[8];
};

/* 13 */
union __attribute__((aligned(32))) __m256d
{
  double m256d_f64[4];
};

/* 14 */
union __attribute__((aligned(32))) __m256i
{
  __int8 m256i_i8[32];
  __int16 m256i_i16[16];
  __int32 m256i_i32[8];
  __int64 m256i_i64[4];
  unsigned __int8 m256i_u8[32];
  unsigned __int16 m256i_u16[16];
  unsigned __int32 m256i_u32[8];
  unsigned __int64 m256i_u64[4];
};

/* 15 */
union __attribute__((aligned(64))) __m512
{
  float m512_f32[16];
};

/* 16 */
union __attribute__((aligned(64))) __m512d
{
  double m512d_f64[8];
};

/* 17 */
union __attribute__((aligned(64))) __m512i
{
  __int8 m512i_i8[64];
  __int16 m512i_i16[32];
  __int32 m512i_i32[16];
  __int64 m512i_i64[8];
  unsigned __int8 m512i_u8[64];
  unsigned __int16 m512i_u16[32];
  unsigned __int32 m512i_u32[16];
  unsigned __int64 m512i_u64[8];
};

/* 18 */
struct La_i86_retval;

/* 19 */
struct La_i86_regs;

/* 192 */
typedef unsigned __int8 __uint8_t;

/* 94 */
typedef __uint8_t uint8_t;

/* 191 */
typedef unsigned __int16 __uint16_t;

/* 95 */
typedef __uint16_t uint16_t;

/* 190 */
typedef unsigned int __uint32_t;

/* 59 */
typedef __uint32_t uint32_t;

/* 20 */
struct in6_addr
{
  union
  {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
  } __in6_u;
};

/* 21 */
typedef uint16_t in_port_t;

/* 147 */
typedef uint32_t in_addr_t;

/* 22 */
struct in_addr
{
  in_addr_t s_addr;
};

/* 23 */
typedef __int128 __int128;

/* 24 */
typedef __int64 ptrdiff_t;

/* 189 */
typedef unsigned __int64 __uint64_t;

/* 129 */
typedef __uint64_t uint64_t;

/* 31 */
typedef uint64_t Elf64_Addr;

/* 25 */
struct link_map_machine
{
  Elf64_Addr plt;
  Elf64_Addr gotplt;
  void *tlsdesc_table;
};

/* 26 */
struct __attribute__((aligned(8))) r_search_path_struct
{
  r_search_path_elem **dirs;
  int malloced;
};

/* 61 */
typedef unsigned __int64 size_t;

/* 138 */
enum r_dir_status : __int32
{
  r_dir_status::unknown = 0x0,
  r_dir_status::nonexisting = 0x1,
  r_dir_status::existing = 0x2,
};

/* 146 */
struct r_search_path_elem
{
  r_search_path_elem *next;
  const char *what;
  const char *where;
  const char *dirname;
  size_t dirnamelen;
  r_dir_status status[];
};

/* 179 */
typedef unsigned __int64 __dev_t;

/* 163 */
typedef __dev_t dev_t;

/* 180 */
typedef unsigned __int64 __ino64_t;

/* 162 */
typedef __ino64_t ino64_t;

/* 27 */
struct r_file_id
{
  dev_t dev;
  ino64_t ino;
};

/* 28 */
typedef uint32_t Elf_Symndx;

/* 29 */
struct __attribute__((aligned(8))) r_scope_elem
{
  link_map **r_list;
  unsigned int r_nlist;
};

/* 121 */
typedef __int64 Lmid_t;

/* 34 */
typedef uint16_t Elf64_Half;

/* 33 */
typedef uint32_t Elf32_Word;

/* 142 */
typedef Elf64_Half Elf64_Versym;

/* 32 */
typedef uint32_t Elf64_Word;

/* 169 */
struct link_map
{
  Elf64_Addr l_addr;
  char *l_name;
  Elf64_Dyn_0 *l_ld;
  link_map *l_next;
  link_map *l_prev;
  link_map *l_real;
  Lmid_t l_ns;
  libname_list *l_libname;
  Elf64_Dyn_0 *l_info[77];
  const Elf64_Phdr *l_phdr;
  Elf64_Addr l_entry;
  Elf64_Half l_phnum;
  Elf64_Half l_ldnum;
  r_scope_elem l_searchlist;
  r_scope_elem l_symbolic_searchlist;
  link_map *l_loader;
  r_found_version *l_versions;
  unsigned int l_nversions;
  Elf_Symndx l_nbuckets;
  Elf32_Word l_gnu_bitmask_idxbits;
  Elf32_Word l_gnu_shift;
  const Elf64_Addr *l_gnu_bitmask;
  union
  {
    const Elf32_Word *l_gnu_buckets;
    const Elf_Symndx *l_chain;
  };
  union
  {
    const Elf32_Word *l_gnu_chain_zero;
    const Elf_Symndx *l_buckets;
  };
  unsigned int l_direct_opencount;
  _BYTE gap31C[3];
  bool l_nodelete_active;
  bool l_nodelete_pending;
  unsigned int l_x86_feature_1_and;
  unsigned int l_x86_isa_1_needed;
  unsigned int l_1_needed;
  r_search_path_struct l_rpath_dirs;
  reloc_result *l_reloc_result;
  Elf64_Versym *l_versyms;
  const char *l_origin;
  Elf64_Addr l_map_start;
  Elf64_Addr l_map_end;
  Elf64_Addr l_text_end;
  r_scope_elem *l_scope_mem[4];
  size_t l_scope_max;
  r_scope_elem **l_scope;
  r_scope_elem *l_local_scope[2];
  r_file_id l_file_id;
  r_search_path_struct l_runpath_dirs;
  link_map **l_initfini;
  link_map_reldeps *l_reldeps;
  unsigned int l_reldepsmax;
  unsigned int l_used;
  Elf64_Word l_feature_1;
  Elf64_Word l_flags_1;
  Elf64_Word l_flags;
  int l_idx;
  link_map_machine l_mach;
  struct
  {
    const Elf64_Sym_0 *sym;
    int type_class;
    link_map *value;
    const Elf64_Sym_0 *ret;
  } l_lookup_cache;
  void *l_tls_initimage;
  size_t l_tls_initimage_size;
  size_t l_tls_blocksize;
  size_t l_tls_align;
  size_t l_tls_firstbyte_offset;
  ptrdiff_t l_tls_offset;
  size_t l_tls_modid;
  size_t l_tls_dtor_count;
  Elf64_Addr l_relro_addr;
  size_t l_relro_size;
  unsigned __int64 l_serial;
};

/* 193 */
typedef __int64 __int64_t;

/* 409 */
typedef __int64_t int64_t;

/* 181 */
typedef int64_t Elf64_Sxword;

/* 182 */
typedef uint64_t Elf64_Xword;

/* 164 */
struct Elf64_Dyn_0
{
  Elf64_Sxword d_tag;
  union
  {
    Elf64_Xword d_val;
    Elf64_Addr d_ptr;
  } d_un;
};

/* 145 */
struct __attribute__((aligned(8))) libname_list
{
  const char *name;
  libname_list *next;
  int dont_free;
};

/* 184 */
typedef uint64_t Elf64_Off;

/* 183 */
struct Elf64_Phdr
{
  Elf64_Word p_type;
  Elf64_Word p_flags;
  Elf64_Off p_offset;
  Elf64_Addr p_vaddr;
  Elf64_Addr p_paddr;
  Elf64_Xword p_filesz;
  Elf64_Xword p_memsz;
  Elf64_Xword p_align;
};

/* 144 */
struct r_found_version
{
  const char *name;
  Elf64_Word hash;
  int hidden;
  const char *filename;
};

/* 143 */
struct reloc_result
{
  Elf64_Addr addr;
  link_map *bound;
  unsigned int boundndx;
  uint32_t enterexit;
  unsigned int flags;
  unsigned int init;
};

/* 141 */
struct link_map_reldeps
{
  unsigned int act;
  link_map *list[];
};

/* 185 */
typedef uint16_t Elf64_Section;

/* 135 */
struct Elf64_Sym_0
{
  Elf64_Word st_name;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  Elf64_Section st_shndx;
  Elf64_Addr st_value;
  Elf64_Xword st_size;
};

/* 237 */
typedef unsigned __int64 _Unwind_Exception_Class;

/* 238 */
enum _Unwind_Reason_Code : __int32
{
  _URC_NO_REASON = 0x0,
  _URC_FOREIGN_EXCEPTION_CAUGHT = 0x1,
  _URC_FATAL_PHASE2_ERROR = 0x2,
  _URC_FATAL_PHASE1_ERROR = 0x3,
  _URC_NORMAL_STOP = 0x4,
  _URC_END_OF_STACK = 0x5,
  _URC_HANDLER_FOUND = 0x6,
  _URC_INSTALL_CONTEXT = 0x7,
  _URC_CONTINUE_UNWIND = 0x8,
};

/* 236 */
typedef void (*_Unwind_Exception_Cleanup_Fn)(_Unwind_Reason_Code, _Unwind_Exception *);

/* 235 */
typedef unsigned __int64 _Unwind_Word;

/* 30 */
struct _Unwind_Exception
{
  union
  {
    struct
    {
      _Unwind_Exception_Class exception_class;
      _Unwind_Exception_Cleanup_Fn exception_cleanup;
      _Unwind_Word private_1;
      _Unwind_Word private_2;
    };
    _Unwind_Word unwind_exception_align[2];
  };
};

/* 35 */
struct __attribute__((aligned(8))) nss_action
{
  nss_module *module;
  unsigned int action_bits;
};

/* 382 */
enum nss_status : __int32
{
  nss_status::NSS_STATUS_TRYAGAIN = 0xFFFFFFFE,
  nss_status::NSS_STATUS_UNAVAIL = 0xFFFFFFFF,
  nss_status::NSS_STATUS_NOTFOUND = 0x0,
  nss_status::NSS_STATUS_SUCCESS = 0x1,
  nss_status::NSS_STATUS_RETURN = 0x2,
};

/* 381 */
typedef nss_status nss_endaliasent(void);

/* 380 */
typedef nss_status nss_endetherent(void);

/* 379 */
typedef nss_status nss_endgrent(void);

/* 378 */
typedef nss_status nss_endhostent(void);

/* 377 */
typedef nss_status nss_endnetent(void);

/* 376 */
typedef nss_status nss_endnetgrent(__netgrent *);

/* 375 */
typedef nss_status nss_endprotoent(void);

/* 374 */
typedef nss_status nss_endpwent(void);

/* 373 */
typedef nss_status nss_endrpcent(void);

/* 372 */
typedef nss_status nss_endservent(void);

/* 371 */
typedef nss_status nss_endsgent(void);

/* 370 */
typedef nss_status nss_endspent(void);

/* 369 */
typedef nss_status nss_getaliasbyname_r(const char *, aliasent *, char *, size_t, int *);

/* 368 */
typedef nss_status nss_getaliasent_r(aliasent *, char *, size_t, int *);

/* 367 */
typedef nss_status nss_getcanonname_r(const char *, char *, size_t, char **, int *, int *);

/* 366 */
typedef nss_status nss_getetherent_r(etherent *, char *, size_t, int *);

/* 365 */
typedef nss_status nss_getgrent_r(group *, char *, size_t, int *);

/* 282 */
typedef unsigned int __gid_t;

/* 364 */
typedef nss_status nss_getgrgid_r(__gid_t, group *, char *, size_t, int *);

/* 363 */
typedef nss_status nss_getgrnam_r(const char *, group *, char *, size_t, int *);

/* 309 */
typedef unsigned int __socklen_t;

/* 262 */
typedef int __int32_t;

/* 265 */
typedef __int32_t int32_t;

/* 362 */
typedef nss_status nss_gethostbyaddr2_r(const void *, __socklen_t, int, hostent *, char *, size_t, int *, int *, int32_t *);

/* 361 */
typedef nss_status nss_gethostbyaddr_r(const void *, __socklen_t, int, hostent *, char *, size_t, int *, int *);

/* 360 */
typedef nss_status nss_gethostbyname2_r(const char *, int, hostent *, char *, size_t, int *, int *);

/* 359 */
typedef nss_status nss_gethostbyname3_r(const char *, int, hostent *, char *, size_t, int *, int *, int32_t *, char **);

/* 358 */
typedef nss_status nss_gethostbyname4_r(const char *, gaih_addrtuple **, char *, size_t, int *, int *, int32_t *);

/* 357 */
typedef nss_status nss_gethostbyname_r(const char *, hostent *, char *, size_t, int *, int *);

/* 356 */
typedef nss_status nss_gethostent_r(hostent *, char *, size_t, int *, int *);

/* 355 */
typedef nss_status nss_gethostton_r(const char *, etherent *, char *, size_t, int *);

/* 354 */
typedef nss_status nss_getnetbyaddr_r(uint32_t, int, netent *, char *, size_t, int *, int *);

/* 353 */
typedef nss_status nss_getnetbyname_r(const char *, netent *, char *, size_t, int *, int *);

/* 352 */
typedef nss_status nss_getnetent_r(netent *, char *, size_t, int *, int *);

/* 351 */
typedef nss_status nss_getnetgrent_r(__netgrent *, char *, size_t, int *);

/* 350 */
typedef nss_status nss_getntohost_r(const ether_addr *, etherent *, char *, size_t, int *);

/* 349 */
typedef nss_status nss_getprotobyname_r(const char *, protoent *, char *, size_t, int *);

/* 348 */
typedef nss_status nss_getprotobynumber_r(int, protoent *, char *, size_t, int *);

/* 347 */
typedef nss_status nss_getprotoent_r(protoent *, char *, size_t, int *);

/* 346 */
typedef nss_status nss_getpublickey(const char *, char *, int *);

/* 345 */
typedef nss_status nss_getpwent_r(passwd *, char *, size_t, int *);

/* 344 */
typedef nss_status nss_getpwnam_r(const char *, passwd *, char *, size_t, int *);

/* 276 */
typedef unsigned int __uid_t;

/* 343 */
typedef nss_status nss_getpwuid_r(__uid_t, passwd *, char *, size_t, int *);

/* 342 */
typedef nss_status nss_getrpcbyname_r(const char *, rpcent *, char *, size_t, int *);

/* 341 */
typedef nss_status nss_getrpcbynumber_r(int, rpcent *, char *, size_t, int *);

/* 340 */
typedef nss_status nss_getrpcent_r(rpcent *, char *, size_t, int *);

/* 339 */
typedef nss_status nss_getsecretkey(const char *, char *, char *, int *);

/* 338 */
typedef nss_status nss_getservbyname_r(const char *, const char *, servent *, char *, size_t, int *);

/* 337 */
typedef nss_status nss_getservbyport_r(int, const char *, servent *, char *, size_t, int *);

/* 336 */
typedef nss_status nss_getservent_r(servent *, char *, size_t, int *);

/* 335 */
typedef nss_status nss_getsgent_r(sgrp *, char *, size_t, int *);

/* 334 */
typedef nss_status nss_getsgnam_r(const char *, sgrp *, char *, size_t, int *);

/* 333 */
typedef nss_status nss_getspent_r(spwd *, char *, size_t, int *);

/* 332 */
typedef nss_status nss_getspnam_r(const char *, spwd *, char *, size_t, int *);

/* 331 */
typedef nss_status nss_initgroups_dyn(const char *, __gid_t, __int64 *, __int64 *, __gid_t **, __int64, int *);

/* 330 */
typedef nss_status nss_netname2user(char *, __uid_t *, __gid_t *, int *, __gid_t *, int *);

/* 329 */
typedef nss_status nss_setaliasent(void);

/* 328 */
typedef nss_status nss_setetherent(int);

/* 327 */
typedef nss_status nss_setgrent(int);

/* 326 */
typedef nss_status nss_sethostent(int);

/* 325 */
typedef nss_status nss_setnetent(int);

/* 324 */
typedef nss_status nss_setnetgrent(const char *, __netgrent *);

/* 323 */
typedef nss_status nss_setprotoent(int);

/* 322 */
typedef nss_status nss_setpwent(int);

/* 321 */
typedef nss_status nss_setrpcent(int);

/* 320 */
typedef nss_status nss_setservent(int);

/* 319 */
typedef nss_status nss_setsgent(int);

/* 318 */
typedef nss_status nss_setspent(int);

/* 317 */
struct nss_module_functions
{
  nss_endaliasent *endaliasent;
  nss_endetherent *endetherent;
  nss_endgrent *endgrent;
  nss_endhostent *endhostent;
  nss_endnetent *endnetent;
  nss_endnetgrent *endnetgrent;
  nss_endprotoent *endprotoent;
  nss_endpwent *endpwent;
  nss_endrpcent *endrpcent;
  nss_endservent *endservent;
  nss_endsgent *endsgent;
  nss_endspent *endspent;
  nss_getaliasbyname_r *getaliasbyname_r;
  nss_getaliasent_r *getaliasent_r;
  nss_getcanonname_r *getcanonname_r;
  nss_getetherent_r *getetherent_r;
  nss_getgrent_r *getgrent_r;
  nss_getgrgid_r *getgrgid_r;
  nss_getgrnam_r *getgrnam_r;
  nss_gethostbyaddr2_r *gethostbyaddr2_r;
  nss_gethostbyaddr_r *gethostbyaddr_r;
  nss_gethostbyname2_r *gethostbyname2_r;
  nss_gethostbyname3_r *gethostbyname3_r;
  nss_gethostbyname4_r *gethostbyname4_r;
  nss_gethostbyname_r *gethostbyname_r;
  nss_gethostent_r *gethostent_r;
  nss_gethostton_r *gethostton_r;
  nss_getnetbyaddr_r *getnetbyaddr_r;
  nss_getnetbyname_r *getnetbyname_r;
  nss_getnetent_r *getnetent_r;
  nss_getnetgrent_r *getnetgrent_r;
  nss_getntohost_r *getntohost_r;
  nss_getprotobyname_r *getprotobyname_r;
  nss_getprotobynumber_r *getprotobynumber_r;
  nss_getprotoent_r *getprotoent_r;
  nss_getpublickey *getpublickey;
  nss_getpwent_r *getpwent_r;
  nss_getpwnam_r *getpwnam_r;
  nss_getpwuid_r *getpwuid_r;
  nss_getrpcbyname_r *getrpcbyname_r;
  nss_getrpcbynumber_r *getrpcbynumber_r;
  nss_getrpcent_r *getrpcent_r;
  nss_getsecretkey *getsecretkey;
  nss_getservbyname_r *getservbyname_r;
  nss_getservbyport_r *getservbyport_r;
  nss_getservent_r *getservent_r;
  nss_getsgent_r *getsgent_r;
  nss_getsgnam_r *getsgnam_r;
  nss_getspent_r *getspent_r;
  nss_getspnam_r *getspnam_r;
  nss_initgroups_dyn *initgroups_dyn;
  nss_netname2user *netname2user;
  nss_setaliasent *setaliasent;
  nss_setetherent *setetherent;
  nss_setgrent *setgrent;
  nss_sethostent *sethostent;
  nss_setnetent *setnetent;
  nss_setnetgrent *setnetgrent;
  nss_setprotoent *setprotoent;
  nss_setpwent *setpwent;
  nss_setrpcent *setrpcent;
  nss_setservent *setservent;
  nss_setsgent *setsgent;
  nss_setspent *setspent;
};

/* 316 */
typedef void *nss_module_functions_untyped[64];

/* 315 */
struct nss_module
{
  int state;
  union
  {
    nss_module_functions typed;
    nss_module_functions_untyped untyped;
  } functions;
  void *handle;
  nss_module *next;
  char name[];
};

/* 41 */
struct __netgrent
{
  enum : __int32
  {
    triple_val = 0x0,
    group_val = 0x1,
  } type;
  union
  {
    struct
    {
      const char *host;
      const char *user;
      const char *domain;
    } triple;
    const char *group;
  } val;
  char *data;
  size_t data_size;
  union
  {
    char *cursor;
    unsigned __int64 position;
  };
  int first;
  name_list *known_groups;
  name_list *needed_groups;
  nss_action *nip;
};

/* 40 */
struct __attribute__((aligned(8))) aliasent
{
  char *alias_name;
  size_t alias_members_len;
  char **alias_members;
  int alias_local;
};

/* 66 */
struct ether_addr
{
  uint8_t ether_addr_octet[6];
};

/* 39 */
struct __attribute__((aligned(4))) etherent
{
  const char *e_name;
  ether_addr e_addr;
};

/* 58 */
struct group
{
  char *gr_name;
  char *gr_passwd;
  __gid_t gr_gid;
  char **gr_mem;
};

/* 57 */
struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;
};

/* 383 */
struct gaih_addrtuple
{
  gaih_addrtuple *next;
  char *name;
  int family;
  uint32_t addr[4];
  uint32_t scopeid;
};

/* 56 */
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};

/* 55 */
struct __attribute__((aligned(8))) protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};

/* 38 */
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};

/* 64 */
struct __attribute__((aligned(8))) rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

/* 54 */
struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};

/* 37 */
struct sgrp
{
  char *sg_namp;
  char *sg_passwd;
  char **sg_adm;
  char **sg_mem;
};

/* 36 */
struct spwd
{
  char *sp_namp;
  char *sp_pwdp;
  __int64 sp_lstchg;
  __int64 sp_min;
  __int64 sp_max;
  __int64 sp_warn;
  __int64 sp_inact;
  __int64 sp_expire;
  unsigned __int64 sp_flag;
};

/* 314 */
struct name_list
{
  name_list *next;
  char name[];
};

/* 392 */
enum xdr_op : __int32
{
  xdr_op::XDR_ENCODE = 0x0,
  xdr_op::XDR_DECODE = 0x1,
  xdr_op::XDR_FREE = 0x2,
};

/* 406 */
typedef char *__caddr_t;

/* 394 */
typedef __caddr_t caddr_t;

/* 407 */
typedef unsigned int __u_int;

/* 391 */
typedef __u_int u_int;

/* 42 */
struct __attribute__((aligned(8))) XDR
{
  xdr_op x_op;
  xdr_ops *x_ops;
  caddr_t x_public;
  caddr_t x_private;
  caddr_t x_base;
  u_int x_handy;
};

/* 395 */
typedef int bool_t;

/* 393 */
struct xdr_ops
{
  bool_t (*x_getlong)(XDR *, __int64 *);
  bool_t (*x_putlong)(XDR *, const __int64 *);
  bool_t (*x_getbytes)(XDR *, caddr_t, u_int);
  bool_t (*x_putbytes)(XDR *, const char *, u_int);
  u_int (*x_getpostn)(const XDR *);
  bool_t (*x_setpostn)(XDR *, u_int);
  int32_t *(*x_inline)(XDR *, u_int);
  void (*x_destroy)(XDR *);
  bool_t (*x_getint32)(XDR *, int32_t *);
  bool_t (*x_putint32)(XDR *, const int32_t *);
};

/* 398 */
struct __mbstate_t
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
};

/* 43 */
struct __gconv_step_data
{
  unsigned __int8 *__outbuf;
  unsigned __int8 *__outbufend;
  int __flags;
  int __invocation_counter;
  int __internal_use;
  __mbstate_t *__statep;
  __mbstate_t __state;
};

/* 44 */
typedef void (*__gconv_end_fct)(__gconv_step *);

/* 91 */
typedef int (*__gconv_fct)(__gconv_step *, __gconv_step_data *, const unsigned __int8 **, const unsigned __int8 *, unsigned __int8 **, size_t *, int, int);

/* 400 */
typedef unsigned int wint_t;

/* 46 */
typedef wint_t (*__gconv_btowc_fct)(__gconv_step *, unsigned __int8);

/* 45 */
typedef int (*__gconv_init_fct)(__gconv_step *);

/* 47 */
struct __gconv_step
{
  __gconv_loaded_object *__shlib_handle;
  const char *__modname;
  int __counter;
  char *__from_name;
  char *__to_name;
  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;
  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;
  int __stateful;
  void *__data;
};

/* 399 */
struct __gconv_loaded_object
{
  const char *name;
  int counter;
  void *handle;
  __gconv_fct fct;
  __gconv_init_fct init_fct;
  __gconv_end_fct end_fct;
};

/* 48 */
struct _IO_iconv_t
{
  __gconv_step *step;
  __gconv_step_data step_data;
};

/* 49 */
struct _IO_lock_t
{
  int lock;
  int cnt;
  void *owner;
};

/* 390 */
typedef unsigned __int64 __u_long;

/* 389 */
typedef __u_long u_long;

/* 155 */
typedef unsigned __int16 sa_family_t;

/* 156 */
struct sockaddr_in
{
  sa_family_t sin_family;
  in_port_t sin_port;
  in_addr sin_addr;
  unsigned __int8 sin_zero[8];
};

/* 429 */
typedef cache_node *cache_ptr;

/* 50 */
struct cache_node
{
  u_long cache_xid;
  u_long cache_proc;
  u_long cache_vers;
  u_long cache_prog;
  sockaddr_in cache_addr;
  char *cache_reply;
  u_long cache_replylen;
  cache_ptr cache_next;
};

/* 423 */
typedef unsigned __int16 __u_short;

/* 418 */
typedef __u_short u_short;

/* 421 */
typedef int enum_t;

/* 432 */
struct __attribute__((aligned(8))) opaque_auth
{
  enum_t oa_flavor;
  caddr_t oa_base;
  u_int oa_length;
};

/* 51 */
struct SVCXPRT
{
  int xp_sock;
  u_short xp_port;
  const xp_ops *xp_ops;
  int xp_addrlen;
  sockaddr_in xp_raddr;
  opaque_auth xp_verf;
  caddr_t xp_p1;
  caddr_t xp_p2;
  char xp_pad[256];
};

/* 443 */
enum xprt_stat : __int32
{
  xprt_stat::XPRT_DIED = 0x0,
  xprt_stat::XPRT_MOREREQS = 0x1,
  xprt_stat::XPRT_IDLE = 0x2,
};

/* 408 */
typedef bool_t (*xdrproc_t)(XDR *, void *, ...);

/* 431 */
struct xp_ops
{
  bool_t (*xp_recv)(SVCXPRT *, rpc_msg *);
  xprt_stat (*xp_stat)(SVCXPRT *);
  bool_t (*xp_getargs)(SVCXPRT *, xdrproc_t, caddr_t);
  bool_t (*xp_reply)(SVCXPRT *, rpc_msg *);
  bool_t (*xp_freeargs)(SVCXPRT *, xdrproc_t, caddr_t);
  void (*xp_destroy)(SVCXPRT *);
};

/* 433 */
enum msg_type : __int32
{
  msg_type::CALL = 0x0,
  msg_type::REPLY = 0x1,
};

/* 435 */
struct call_body
{
  u_long cb_rpcvers;
  u_long cb_prog;
  u_long cb_vers;
  u_long cb_proc;
  opaque_auth cb_cred;
  opaque_auth cb_verf;
};

/* 436 */
enum reply_stat : __int32
{
  reply_stat::MSG_ACCEPTED = 0x0,
  reply_stat::MSG_DENIED = 0x1,
};

/* 440 */
enum accept_stat : __int32
{
  accept_stat::SUCCESS = 0x0,
  accept_stat::PROG_UNAVAIL = 0x1,
  accept_stat::PROG_MISMATCH = 0x2,
  accept_stat::PROC_UNAVAIL = 0x3,
  accept_stat::GARBAGE_ARGS = 0x4,
  accept_stat::SYSTEM_ERR = 0x5,
};

/* 438 */
struct accepted_reply
{
  opaque_auth ar_verf;
  accept_stat ar_stat;
  union
  {
    struct
    {
      u_long low;
      u_long high;
    } AR_versions;
    struct
    {
      caddr_t where;
      xdrproc_t proc;
    } AR_results;
  } ru;
};

/* 439 */
enum reject_stat : __int32
{
  reject_stat::RPC_MISMATCH = 0x0,
  reject_stat::AUTH_ERROR = 0x1,
};

/* 388 */
enum auth_stat : __int32
{
  auth_stat::AUTH_OK = 0x0,
  auth_stat::AUTH_BADCRED = 0x1,
  auth_stat::AUTH_REJECTEDCRED = 0x2,
  auth_stat::AUTH_BADVERF = 0x3,
  auth_stat::AUTH_REJECTEDVERF = 0x4,
  auth_stat::AUTH_TOOWEAK = 0x5,
  auth_stat::AUTH_INVALIDRESP = 0x6,
  auth_stat::AUTH_FAILED = 0x7,
};

/* 437 */
struct rejected_reply
{
  reject_stat rj_stat;
  union
  {
    struct
    {
      u_long low;
      u_long high;
    } RJ_versions;
    auth_stat RJ_why;
  } ru;
};

/* 434 */
struct reply_body
{
  reply_stat rp_stat;
  union
  {
    accepted_reply RP_ar;
    rejected_reply RP_dr;
  } ru;
};

/* 430 */
struct rpc_msg
{
  u_long rm_xid;
  msg_type rm_direction;
  union
  {
    call_body RM_cmb;
    reply_body RM_rmb;
  } ru;
};

/* 52 */
struct CLIENT
{
  AUTH *cl_auth;
  clnt_ops *cl_ops;
  caddr_t cl_private;
};

/* 463 */
union des_block
{
  struct
  {
    uint32_t high;
    uint32_t low;
  } key;
  char c[8];
};

/* 53 */
struct AUTH
{
  opaque_auth ah_cred;
  opaque_auth ah_verf;
  des_block ah_key;
  auth_ops *ah_ops;
  caddr_t ah_private;
};

/* 387 */
enum clnt_stat : __int32
{
  clnt_stat::RPC_SUCCESS = 0x0,
  clnt_stat::RPC_CANTENCODEARGS = 0x1,
  clnt_stat::RPC_CANTDECODERES = 0x2,
  clnt_stat::RPC_CANTSEND = 0x3,
  clnt_stat::RPC_CANTRECV = 0x4,
  clnt_stat::RPC_TIMEDOUT = 0x5,
  clnt_stat::RPC_VERSMISMATCH = 0x6,
  clnt_stat::RPC_AUTHERROR = 0x7,
  clnt_stat::RPC_PROGUNAVAIL = 0x8,
  clnt_stat::RPC_PROGVERSMISMATCH = 0x9,
  clnt_stat::RPC_PROCUNAVAIL = 0xA,
  clnt_stat::RPC_CANTDECODEARGS = 0xB,
  clnt_stat::RPC_SYSTEMERROR = 0xC,
  clnt_stat::RPC_NOBROADCAST = 0x15,
  clnt_stat::RPC_UNKNOWNHOST = 0xD,
  clnt_stat::RPC_UNKNOWNPROTO = 0x11,
  clnt_stat::RPC_UNKNOWNADDR = 0x13,
  clnt_stat::RPC_RPCBFAILURE = 0xE,
  clnt_stat::RPC_PROGNOTREGISTERED = 0xF,
  clnt_stat::RPC_N2AXLATEFAILURE = 0x16,
  clnt_stat::RPC_FAILED = 0x10,
  clnt_stat::RPC_INTR = 0x12,
  clnt_stat::RPC_TLIERROR = 0x14,
  clnt_stat::RPC_UDERROR = 0x17,
  clnt_stat::RPC_INPROGRESS = 0x18,
  clnt_stat::RPC_STALERACHANDLE = 0x19,
};

/* 176 */
typedef __int64 __time_t;

/* 177 */
typedef __int64 __suseconds_t;

/* 123 */
struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};

/* 461 */
struct clnt_ops
{
  clnt_stat (*cl_call)(CLIENT *, u_long, xdrproc_t, caddr_t, xdrproc_t, caddr_t, timeval);
  void (*cl_abort)(void);
  void (*cl_geterr)(CLIENT *, rpc_err *);
  bool_t (*cl_freeres)(CLIENT *, xdrproc_t, caddr_t);
  void (*cl_destroy)(CLIENT *);
  bool_t (*cl_control)(CLIENT *, int, char *);
};

/* 462 */
struct auth_ops
{
  void (*ah_nextverf)(AUTH *);
  int (*ah_marshal)(AUTH *, XDR *);
  int (*ah_validate)(AUTH *, opaque_auth *);
  int (*ah_refresh)(AUTH *);
  void (*ah_destroy)(AUTH *);
};

/* 386 */
struct rpc_err
{
  clnt_stat re_status;
  union
  {
    int RE_errno;
    auth_stat RE_why;
    struct
    {
      u_long low;
      u_long high;
    } RE_vers;
    struct
    {
      __int64 s1;
      __int64 s2;
    } RE_lb;
  } ru;
};

/* 60 */
struct parser_data
{
  char linebuffer[];
};

/* 62 */
typedef __int64 __off64_t;

/* 63 */
typedef __int64 __off_t;

/* 122 */
typedef __time_t time_t;

/* 65 */
struct traced_file
{
  time_t mtime;
  traced_file *next;
  int call_res_init;
  int inotify_descr[2];
  char dname[4096];
  char *sfname;
  char fname[];
};

/* 72 */
typedef __off_t off_t;

/* 589 */
union locale_data_value
{
  const uint32_t *wstr;
  const char *string;
  unsigned int word;
};

/* 67 */
struct __locale_data
{
  const char *name;
  const char *filedata;
  off_t filesize;
  enum : __int32
  {
    ld_malloced = 0x0,
    ld_mapped = 0x1,
    ld_archive = 0x2,
  } alloc;
  struct
  {
    void (*cleanup)(__locale_data *);
    union
    {
      void *data;
      lc_time_data *time;
      const gconv_fcts *ctype;
    };
  } private;
  unsigned int usage_count;
  int use_translit;
  unsigned int nstrings;
  locale_data_value values[];
};

/* 397 */
typedef int wchar_t;

/* 591 */
struct lc_time_data
{
  era_entry *eras;
  size_t num_eras;
  int era_initialized;
  const char **alt_digits;
  const wchar_t **walt_digits;
  int alt_digits_initialized;
  int walt_digits_initialized;
};

/* 590 */
struct gconv_fcts
{
  __gconv_step *towc;
  size_t towc_nsteps;
  __gconv_step *tomb;
  size_t tomb_nsteps;
};

/* 588 */
struct __attribute__((aligned(8))) era_entry
{
  uint32_t direction;
  int32_t offset;
  int32_t start_date[3];
  int32_t stop_date[3];
  const char *era_name;
  const char *era_format;
  const wchar_t *era_wname;
  const wchar_t *era_wformat;
  int absolute_direction;
};

/* 68 */
struct ax25_address
{
  char ax25_call[7];
};

/* 69 */
struct __attribute__((aligned(8))) obstack
{
  __int64 chunk_size;
  _obstack_chunk *chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  union
  {
    __int64 tempint;
    void *tempptr;
  } temp;
  int alignment_mask;
  _obstack_chunk *(*chunkfun)(void *, __int64);
  void (*freefun)(void *, _obstack_chunk *);
  void *extra_arg;
  _BYTE gap50[8];
};

/* 868 */
struct __attribute__((aligned(8))) _obstack_chunk
{
  char *limit;
  _obstack_chunk *prev;
  char contents[4];
};

/* 70 */
struct __va_list_tag
{
  unsigned int gp_offset;
  unsigned int fp_offset;
  void *overflow_arg_area;
  void *reg_save_area;
};

/* 71 */
typedef __va_list_tag __builtin_va_list[1];

/* 401 */
typedef _IO_FILE_0 FILE;

/* 73 */
typedef void (*_IO_imbue_t)(FILE *, void *);

/* 642 */
struct _IO_FILE_0
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  _IO_marker *_markers;
  _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned __int16 _cur_column;
  char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  _IO_codecvt *_codecvt;
  _IO_wide_data *_wide_data;
  _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  char _unused2[20];
};

/* 405 */
struct __attribute__((aligned(8))) _IO_marker
{
  _IO_marker *_next;
  FILE *_sbuf;
  int _pos;
};

/* 404 */
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  _IO_marker *_markers;
  _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned __int16 _cur_column;
  char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  _IO_codecvt *_codecvt;
  _IO_wide_data *_wide_data;
  _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  char _unused2[20];
};

/* 403 */
struct _IO_codecvt
{
  _IO_iconv_t __cd_in;
  _IO_iconv_t __cd_out;
};

/* 402 */
struct _IO_wide_data
{
  wchar_t *_IO_read_ptr;
  wchar_t *_IO_read_end;
  wchar_t *_IO_read_base;
  wchar_t *_IO_write_base;
  wchar_t *_IO_write_ptr;
  wchar_t *_IO_write_end;
  wchar_t *_IO_buf_base;
  wchar_t *_IO_buf_end;
  wchar_t *_IO_save_base;
  wchar_t *_IO_backup_base;
  wchar_t *_IO_save_end;
  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  _IO_codecvt _codecvt;
  wchar_t _shortbuf[1];
  const _IO_jump_t *_wide_vtable;
};

/* 90 */
typedef void (*_IO_finish_t)(FILE *, int);

/* 89 */
typedef int (*_IO_overflow_t)(FILE *, int);

/* 88 */
typedef int (*_IO_underflow_t)(FILE *);

/* 87 */
typedef int (*_IO_pbackfail_t)(FILE *, int);

/* 86 */
typedef size_t (*_IO_xsputn_t)(FILE *, const void *, size_t);

/* 85 */
typedef size_t (*_IO_xsgetn_t)(FILE *, void *, size_t);

/* 515 */
typedef __off64_t off64_t;

/* 84 */
typedef off64_t (*_IO_seekoff_t)(FILE *, off64_t, int, int);

/* 83 */
typedef off64_t (*_IO_seekpos_t)(FILE *, off64_t, int);

/* 279 */
typedef __int64 __ssize_t;

/* 516 */
typedef __ssize_t ssize_t;

/* 82 */
typedef FILE *(*_IO_setbuf_t)(FILE *, char *, ssize_t);

/* 81 */
typedef int (*_IO_sync_t)(FILE *);

/* 80 */
typedef int (*_IO_doallocate_t)(FILE *);

/* 79 */
typedef ssize_t (*_IO_read_t)(FILE *, void *, ssize_t);

/* 78 */
typedef ssize_t (*_IO_write_t)(FILE *, const void *, ssize_t);

/* 77 */
typedef off64_t (*_IO_seek_t)(FILE *, off64_t, int);

/* 76 */
typedef int (*_IO_close_t)(FILE *);

/* 75 */
typedef int (*_IO_stat_t)(FILE *, void *);

/* 74 */
typedef int (*_IO_showmanyc_t)(FILE *);

/* 396 */
struct _IO_jump_t
{
  size_t __dummy;
  size_t __dummy2;
  _IO_finish_t __finish;
  _IO_overflow_t __overflow;
  _IO_underflow_t __underflow;
  _IO_underflow_t __uflow;
  _IO_pbackfail_t __pbackfail;
  _IO_xsputn_t __xsputn;
  _IO_xsgetn_t __xsgetn;
  _IO_seekoff_t __seekoff;
  _IO_seekpos_t __seekpos;
  _IO_setbuf_t __setbuf;
  _IO_sync_t __sync;
  _IO_doallocate_t __doallocate;
  _IO_read_t __read;
  _IO_write_t __write;
  _IO_seek_t __seek;
  _IO_close_t __close;
  _IO_stat_t __stat;
  _IO_showmanyc_t __showmanyc;
  _IO_imbue_t __imbue;
};

/* 92 */
struct _Unwind_Context;

/* 93 */
struct argp_state
{
  const argp *root_argp;
  int argc;
  char **argv;
  int next;
  unsigned int flags;
  unsigned int arg_num;
  int quoted;
  void *input;
  void **child_inputs;
  void *hook;
  char *name;
  FILE *err_stream;
  FILE *out_stream;
  void *pstate;
};

/* 625 */
typedef int error_t;

/* 624 */
typedef error_t (*argp_parser_t)(int, char *, argp_state *);

/* 623 */
struct argp
{
  const argp_option *options;
  argp_parser_t parser;
  const char *args_doc;
  const char *doc;
  const argp_child *children;
  char *(*help_filter)(int, const char *, void *);
  const char *argp_domain;
};

/* 626 */
struct __attribute__((aligned(8))) argp_option
{
  const char *name;
  int key;
  const char *arg;
  int flags;
  const char *doc;
  int group;
};

/* 622 */
struct __attribute__((aligned(8))) argp_child
{
  const argp *argp;
  int flags;
  const char *header;
  int group;
};

/* 579 */
typedef unsigned __int16 __u16;

/* 599 */
typedef __u16 __be16;

/* 97 */
typedef unsigned __int8 __u8;

/* 96 */
struct __attribute__((aligned(2))) atalk_addr
{
  __be16 s_net;
  __u8 s_node;
};

/* 98 */
typedef unsigned __int16 __kernel_sa_family_t;

/* 99 */
typedef int __libc_lock_t;

/* 101 */
typedef unsigned __int64 bitset_word_t;

/* 100 */
typedef bitset_word_t bitset_t[4];

/* 696 */
typedef int regoff_t;

/* 102 */
typedef regoff_t Idx;

/* 793 */
typedef unsigned int __re_size_t;

/* 103 */
typedef __re_size_t re_hashval_t;

/* 104 */
typedef bitset_word_t *re_bitset_ptr_t;

/* 313 */
typedef unsigned __int64 __nlink_t;

/* 312 */
typedef unsigned int __mode_t;

/* 311 */
typedef __int64 __blksize_t;

/* 310 */
typedef __int64 __blkcnt64_t;

/* 175 */
typedef __int64 __syscall_slong_t;

/* 124 */
struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};

/* 105 */
struct stat64
{
  __dev_t st_dev;
  __ino64_t st_ino;
  __nlink_t st_nlink;
  __mode_t st_mode;
  __uid_t st_uid;
  __gid_t st_gid;
  int __pad0;
  __dev_t st_rdev;
  __off_t st_size;
  __blksize_t st_blksize;
  __blkcnt64_t st_blocks;
  timespec st_atim;
  timespec st_mtim;
  timespec st_ctim;
  __syscall_slong_t __glibc_reserved[3];
};

/* 704 */
typedef unsigned __int64 __ino_t;

/* 751 */
typedef __int64 __blkcnt_t;

/* 106 */
struct stat
{
  __dev_t st_dev;
  __ino_t st_ino;
  __nlink_t st_nlink;
  __mode_t st_mode;
  __uid_t st_uid;
  __gid_t st_gid;
  int __pad0;
  __dev_t st_rdev;
  __off_t st_size;
  __blksize_t st_blksize;
  __blkcnt_t st_blocks;
  timespec st_atim;
  timespec st_mtim;
  timespec st_ctim;
  __syscall_slong_t __glibc_reserved[3];
};

/* 107 */
struct rusage
{
  timeval ru_utime;
  timeval ru_stime;
  union
  {
    __int64 ru_maxrss;
    __syscall_slong_t __ru_maxrss_word;
  };
  union
  {
    __int64 ru_ixrss;
    __syscall_slong_t __ru_ixrss_word;
  };
  union
  {
    __int64 ru_idrss;
    __syscall_slong_t __ru_idrss_word;
  };
  union
  {
    __int64 ru_isrss;
    __syscall_slong_t __ru_isrss_word;
  };
  union
  {
    __int64 ru_minflt;
    __syscall_slong_t __ru_minflt_word;
  };
  union
  {
    __int64 ru_majflt;
    __syscall_slong_t __ru_majflt_word;
  };
  union
  {
    __int64 ru_nswap;
    __syscall_slong_t __ru_nswap_word;
  };
  union
  {
    __int64 ru_inblock;
    __syscall_slong_t __ru_inblock_word;
  };
  union
  {
    __int64 ru_oublock;
    __syscall_slong_t __ru_oublock_word;
  };
  union
  {
    __int64 ru_msgsnd;
    __syscall_slong_t __ru_msgsnd_word;
  };
  union
  {
    __int64 ru_msgrcv;
    __syscall_slong_t __ru_msgrcv_word;
  };
  union
  {
    __int64 ru_nsignals;
    __syscall_slong_t __ru_nsignals_word;
  };
  union
  {
    __int64 ru_nvcsw;
    __syscall_slong_t __ru_nvcsw_word;
  };
  union
  {
    __int64 ru_nivcsw;
    __syscall_slong_t __ru_nivcsw_word;
  };
};

/* 108 */
typedef long double _Float128;

/* 109 */
typedef __m128i _0;

/* 110 */
typedef __m128i __m128i_0;

/* 111 */
struct malloc_chunk
{
  size_t mchunk_prev_size;
  size_t mchunk_size;
  malloc_chunk *fd;
  malloc_chunk *bk;
  malloc_chunk *fd_nextsize;
  malloc_chunk *bk_nextsize;
};

/* 112 */
typedef malloc_chunk *mchunkptr;

/* 871 */
typedef malloc_chunk *mfastbinptr;

/* 113 */
struct malloc_state
{
  __libc_lock_t mutex;
  int flags;
  int have_fastchunks;
  mfastbinptr fastbinsY[10];
  mchunkptr top;
  mchunkptr last_remainder;
  mchunkptr bins[254];
  unsigned int binmap[4];
  malloc_state *next;
  malloc_state *next_free;
  size_t attached_threads;
  size_t system_mem;
  size_t max_system_mem;
};

/* 114 */
typedef int kernel_timer_t;

/* 115 */
union pthread_attr_t
{
  char __size[56];
  __int64 __align;
};

/* 118 */
enum expression_operator : __int32
{
  expression_operator::var = 0x0,
  expression_operator::num = 0x1,
  expression_operator::lnot = 0x2,
  expression_operator::mult = 0x3,
  expression_operator::divide = 0x4,
  expression_operator::module = 0x5,
  expression_operator::plus = 0x6,
  expression_operator::minus = 0x7,
  expression_operator::less_than = 0x8,
  expression_operator::greater_than = 0x9,
  expression_operator::less_or_equal = 0xA,
  expression_operator::greater_or_equal = 0xB,
  expression_operator::equal = 0xC,
  expression_operator::not_equal = 0xD,
  expression_operator::land = 0xE,
  expression_operator::lor = 0xF,
  expression_operator::qmop = 0x10,
};

/* 116 */
struct expression
{
  int nargs;
  expression_operator operation;
  union
  {
    unsigned __int64 num;
    expression *args[3];
  } val;
};

/* 117 */
struct loaded_l10nfile
{
  const char *filename;
  int decided;
  const void *data;
  loaded_l10nfile *next;
  loaded_l10nfile *successor[1];
};

/* 119 */
typedef unsigned int ui32;

/* 120 */
struct dl_find_object
{
  unsigned __int64 dlfo_flags;
  void *dlfo_map_start;
  void *dlfo_map_end;
  link_map *dlfo_link_map;
  void *dlfo_eh_frame;
  unsigned __int64 __dflo_reserved[7];
};

/* 178 */
typedef int __clockid_t;

/* 125 */
typedef __clockid_t clockid_t;

/* 126 */
struct Elf64_auxv_t
{
  uint64_t a_type;
  union
  {
    uint64_t a_val;
  } a_un;
};

/* 131 */
typedef unsigned __int16 fpu_control_t;

/* 173 */
enum cpu_features_kind : __int32
{
  cpu_features_kind::arch_kind_unknown = 0x0,
  cpu_features_kind::arch_kind_intel = 0x1,
  cpu_features_kind::arch_kind_amd = 0x2,
  cpu_features_kind::arch_kind_zhaoxin = 0x3,
  cpu_features_kind::arch_kind_other = 0x4,
};

/* 171 */
struct cpu_features_basic
{
  cpu_features_kind kind;
  int max_cpuid;
  unsigned int family;
  unsigned int model;
  unsigned int stepping;
};

/* 172 */
struct cpuid_registers
{
  unsigned int eax;
  unsigned int ebx;
  unsigned int ecx;
  unsigned int edx;
};

/* 170 */
struct cpuid_feature_internal
{
  union
  {
    unsigned int cpuid_array[4];
    cpuid_registers cpuid;
  };
  union
  {
    unsigned int active_array[4];
    cpuid_registers active;
  };
};

/* 130 */
struct cpu_features
{
  cpu_features_basic basic;
  cpuid_feature_internal features[9];
  unsigned int preferred[1];
  unsigned int isa_1;
  unsigned __int64 xsave_state_size;
  unsigned int xsave_state_full_size;
  unsigned __int64 data_cache_size;
  unsigned __int64 shared_cache_size;
  unsigned __int64 non_temporal_threshold;
  unsigned __int64 rep_movsb_threshold;
  unsigned __int64 rep_movsb_stop_threshold;
  unsigned __int64 rep_stosb_threshold;
  unsigned __int64 level1_icache_size;
  unsigned __int64 level1_icache_linesize;
  unsigned __int64 level1_dcache_size;
  unsigned __int64 level1_dcache_assoc;
  unsigned __int64 level1_dcache_linesize;
  unsigned __int64 level2_cache_size;
  unsigned __int64 level2_cache_assoc;
  unsigned __int64 level2_cache_linesize;
  unsigned __int64 level3_cache_size;
  unsigned __int64 level3_cache_assoc;
  unsigned __int64 level3_cache_linesize;
  unsigned __int64 level4_cache_size;
};

/* 128 */
enum dso_sort_algorithm : __int32
{
  dso_sort_algorithm::dso_sort_algorithm_original = 0x0,
  dso_sort_algorithm::dso_sort_algorithm_dfs = 0x1,
};

/* 204 */
typedef link_map *lookup_t;

/* 127 */
struct __attribute__((aligned(8))) rtld_global_ro
{
  int _dl_debug_mask;
  unsigned int _dl_osversion;
  const char *_dl_platform;
  size_t _dl_platformlen;
  size_t _dl_pagesize;
  size_t _dl_minsigstacksize;
  int _dl_inhibit_cache;
  r_scope_elem _dl_initial_searchlist;
  int _dl_clktck;
  int _dl_verbose;
  int _dl_debug_fd;
  int _dl_lazy;
  int _dl_bind_not;
  int _dl_dynamic_weak;
  fpu_control_t _dl_fpu_control;
  int _dl_correct_cache_id;
  uint64_t _dl_hwcap;
  Elf64_auxv_t *_dl_auxv;
  cpu_features _dl_x86_cpu_features;
  const char _dl_x86_hwcap_flags[3][9];
  const char _dl_x86_platforms[4][9];
  const char *_dl_inhibit_rpath;
  const char *_dl_origin_path;
  Elf64_Addr _dl_use_load_bias;
  size_t _dl_tls_static_size;
  size_t _dl_tls_static_align;
  size_t _dl_tls_static_surplus;
  const char *_dl_profile;
  const char *_dl_profile_output;
  const char *_dl_trace_prelink;
  link_map *_dl_trace_prelink_map;
  r_search_path_elem *_dl_init_all_dirs;
  const Elf64_Ehdr *_dl_sysinfo_dso;
  link_map *_dl_sysinfo_map;
  int (*_dl_vdso_clock_gettime64)(clockid_t, timespec *);
  int (*_dl_vdso_gettimeofday)(timeval *, void *);
  time_t (*_dl_vdso_time)(time_t *);
  int (*_dl_vdso_getcpu)(unsigned int *, unsigned int *, void *);
  int (*_dl_vdso_clock_getres_time64)(clockid_t, timespec *);
  uint64_t _dl_hwcap2;
  dso_sort_algorithm _dl_dso_sort_algo;
  void (*_dl_debug_printf)(const char *, ...);
  void (*_dl_mcount)(Elf64_Addr, Elf64_Addr);
  lookup_t (*_dl_lookup_symbol_x)(const char *, link_map *, const Elf64_Sym_0 **, r_scope_elem **, const r_found_version *, int, int, link_map *);
  void *(*_dl_open)(const char *, int, const void *, Lmid_t, int, char **, char **);
  void (*_dl_close)(void *);
  int (*_dl_catch_error)(const char **, const char **, bool *, void (*)(void *), void *);
  void (*_dl_error_free)(void *);
  void *(*_dl_tls_get_addr_soft)(link_map *);
  void (*_dl_libc_freeres)(void);
  int (*_dl_find_object)(void *, dl_find_object *);
  int (*_dl_discover_osversion)(void);
  const dlfcn_hook *_dl_dlfcn_hook;
  audit_ifaces *_dl_audit;
  unsigned int _dl_naudit;
};

/* 188 */
struct Elf64_Ehdr
{
  unsigned __int8 e_ident[16];
  Elf64_Half e_type;
  Elf64_Half e_machine;
  Elf64_Word e_version;
  Elf64_Addr e_entry;
  Elf64_Off e_phoff;
  Elf64_Off e_shoff;
  Elf64_Word e_flags;
  Elf64_Half e_ehsize;
  Elf64_Half e_phentsize;
  Elf64_Half e_phnum;
  Elf64_Half e_shentsize;
  Elf64_Half e_shnum;
  Elf64_Half e_shstrndx;
};

/* 140 */
struct dlfcn_hook
{
  void *(*dlopen)(const char *, int, void *);
  int (*dlclose)(void *);
  void *(*dlsym)(void *, const char *, void *);
  void *(*dlvsym)(void *, const char *, const char *, void *);
  char *(*dlerror)(void);
  int (*dladdr)(const void *, Dl_info *);
  int (*dladdr1)(const void *, Dl_info *, void **, int);
  int (*dlinfo)(void *, int, void *);
  void *(*dlmopen)(Lmid_t, const char *, int, void *);
  void *(*libc_dlopen_mode)(const char *, int);
  void *(*libc_dlsym)(void *, const char *);
  void *(*libc_dlvsym)(void *, const char *, const char *);
  int (*libc_dlclose)(void *);
};

/* 136 */
typedef unsigned __int64 uintptr_t;

/* 187 */
typedef uint32_t Elf32_Addr;

/* 132 */
struct audit_ifaces
{
  void (*activity)(uintptr_t *, unsigned int);
  char *(*objsearch)(const char *, uintptr_t *, unsigned int);
  unsigned int (*objopen)(link_map *, Lmid_t, uintptr_t *);
  void (*preinit)(uintptr_t *);
  union
  {
    uintptr_t (*symbind32)(Elf32_Sym *, unsigned int, uintptr_t *, uintptr_t *, unsigned int *, const char *);
    uintptr_t (*symbind64)(Elf64_Sym_0 *, unsigned int, uintptr_t *, uintptr_t *, unsigned int *, const char *);
  };
  union
  {
    Elf32_Addr (*i86_gnu_pltenter)(Elf32_Sym *, unsigned int, uintptr_t *, uintptr_t *, La_i86_regs *, unsigned int *, const char *, __int64 *);
    Elf64_Addr (*x86_64_gnu_pltenter)(Elf64_Sym_0 *, unsigned int, uintptr_t *, uintptr_t *, La_x86_64_regs *, unsigned int *, const char *, __int64 *);
    Elf32_Addr (*x32_gnu_pltenter)(Elf32_Sym *, unsigned int, uintptr_t *, uintptr_t *, La_x86_64_regs *, unsigned int *, const char *, __int64 *);
  };
  union
  {
    unsigned int (*i86_gnu_pltexit)(Elf32_Sym *, unsigned int, uintptr_t *, uintptr_t *, const La_i86_regs *, La_i86_retval *, const char *);
    unsigned int (*x86_64_gnu_pltexit)(Elf64_Sym_0 *, unsigned int, uintptr_t *, uintptr_t *, const La_x86_64_regs *, La_x86_64_retval *, const char *);
    unsigned int (*x32_gnu_pltexit)(Elf32_Sym *, unsigned int, uintptr_t *, uintptr_t *, const La_x86_64_regs *, La_x86_64_retval *, const char *);
  };
  unsigned int (*objclose)(uintptr_t *);
  audit_ifaces *next;
};

/* 139 */
struct Dl_info
{
  const char *dli_fname;
  void *dli_fbase;
  const char *dli_sname;
  void *dli_saddr;
};

/* 186 */
typedef uint16_t Elf32_Section;

/* 137 */
struct Elf32_Sym
{
  Elf32_Word st_name;
  Elf32_Addr st_value;
  Elf32_Word st_size;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  Elf32_Section st_shndx;
};

/* 166 */
struct La_x86_64_xmm
{
  float body[4];
};

/* 168 */
struct La_x86_64_ymm
{
  float body[8];
};

/* 167 */
struct La_x86_64_zmm
{
  double body[8];
};

/* 165 */
union La_x86_64_vector
{
  La_x86_64_ymm ymm[2];
  La_x86_64_zmm zmm[1];
  La_x86_64_xmm xmm[4];
};

/* 134 */
struct La_x86_64_regs
{
  uint64_t lr_rdx;
  uint64_t lr_r8;
  uint64_t lr_r9;
  uint64_t lr_rcx;
  uint64_t lr_rsi;
  uint64_t lr_rdi;
  uint64_t lr_rbp;
  uint64_t lr_rsp;
  La_x86_64_xmm lr_xmm[8];
  La_x86_64_vector lr_vector[8];
  __int128 __glibc_unused1[4];
};

/* 133 */
struct La_x86_64_retval
{
  uint64_t lrv_rax;
  uint64_t lrv_rdx;
  La_x86_64_xmm lrv_xmm0;
  La_x86_64_xmm lrv_xmm1;
  long double lrv_st0;
  long double lrv_st1;
  La_x86_64_vector lrv_vector0;
  La_x86_64_vector lrv_vector1;
  __int128 __glibc_unused1;
  __int128 __glibc_unused2;
};

/* 148 */
struct sockaddr_x25;

/* 149 */
struct sockaddr_un
{
  sa_family_t sun_family;
  char sun_path[108];
};

/* 150 */
struct sockaddr_ns;

/* 151 */
struct sockaddr_iso;

/* 152 */
struct sockaddr_ipx
{
  sa_family_t sipx_family;
  uint16_t sipx_port;
  uint32_t sipx_network;
  unsigned __int8 sipx_node[6];
  uint8_t sipx_type;
  unsigned __int8 sipx_zero;
};

/* 153 */
struct sockaddr_inarp;

/* 154 */
struct sockaddr_in6
{
  sa_family_t sin6_family;
  in_port_t sin6_port;
  uint32_t sin6_flowinfo;
  in6_addr sin6_addr;
  uint32_t sin6_scope_id;
};

/* 157 */
struct sockaddr_eon;

/* 158 */
struct sockaddr_dl;

/* 159 */
struct sockaddr_ax25
{
  sa_family_t sax25_family;
  ax25_address sax25_call;
  int sax25_ndigis;
};

/* 160 */
struct sockaddr_at
{
  __kernel_sa_family_t sat_family;
  __u8 sat_port;
  atalk_addr sat_addr;
  char sat_zero[8];
};

/* 161 */
struct sockaddr
{
  sa_family_t sa_family;
  char sa_data[14];
};

/* 174 */
struct cpuid_feature
{
  unsigned int cpuid_array[4];
  unsigned int active_array[4];
};

/* 197 */
typedef unsigned __int64 __rlim_t;

/* 196 */
typedef __rlim_t rlim_t;

/* 194 */
struct rlimit
{
  rlim_t rlim_cur;
  rlim_t rlim_max;
};

/* 195 */
enum __rlimit_resource : __int32
{
  __rlimit_resource::RLIMIT_CPU = 0x0,
  __rlimit_resource::RLIMIT_FSIZE = 0x1,
  __rlimit_resource::RLIMIT_DATA = 0x2,
  __rlimit_resource::RLIMIT_STACK = 0x3,
  __rlimit_resource::RLIMIT_CORE = 0x4,
  __rlimit_resource::__RLIMIT_RSS = 0x5,
  __rlimit_resource::RLIMIT_NOFILE = 0x7,
  __rlimit_resource::__RLIMIT_OFILE = 0x7,
  __rlimit_resource::RLIMIT_AS = 0x9,
  __rlimit_resource::__RLIMIT_NPROC = 0x6,
  __rlimit_resource::__RLIMIT_MEMLOCK = 0x8,
  __rlimit_resource::__RLIMIT_LOCKS = 0xA,
  __rlimit_resource::__RLIMIT_SIGPENDING = 0xB,
  __rlimit_resource::__RLIMIT_MSGQUEUE = 0xC,
  __rlimit_resource::__RLIMIT_NICE = 0xD,
  __rlimit_resource::__RLIMIT_RTPRIO = 0xE,
  __rlimit_resource::__RLIMIT_RTTIME = 0xF,
  __rlimit_resource::__RLIMIT_NLIMITS = 0x10,
  __rlimit_resource::__RLIM_NLIMITS = 0x10,
};

/* 203 */
typedef unsigned __int64 __cpu_mask;

/* 198 */
struct cpu_set_t
{
  __cpu_mask __bits[16];
};

/* 202 */
struct sched_param
{
  int sched_priority;
};

/* 199 */
struct pthread_attr
{
  sched_param schedparam;
  int schedpolicy;
  int flags;
  size_t guardsize;
  void *stackaddr;
  size_t stacksize;
  pthread_attr_extension *extension;
  void *unused;
};

/* 260 */
struct __sigset_t
{
  unsigned __int64 __val[16];
};

/* 201 */
typedef __sigset_t sigset_t;

/* 200 */
struct __attribute__((aligned(8))) pthread_attr_extension
{
  cpu_set_t *cpuset;
  size_t cpusetsize;
  sigset_t sigmask;
  bool sigmask_set;
};

/* 205 */
struct call_dl_lookup_args
{
  link_map *map;
  const char *name;
  r_found_version *vers;
  int flags;
  lookup_t loadbase;
  const Elf64_Sym_0 **refp;
};

/* 206 */
struct dl_exception
{
  const char *objname;
  const char *errstring;
  char *message_buffer;
};

/* 207 */
typedef dl_tls_index tls_index;

/* 1058 */
struct dl_tls_index
{
  uint64_t ti_module;
  uint64_t ti_offset;
};

/* 208 */
struct dl_scope_free_list
{
  size_t count;
  void *list[50];
};

/* 209 */
struct __attribute__((aligned(8))) auditstate
{
  uintptr_t cookie;
  unsigned int bindflags;
};

/* 250 */
struct __pthread_internal_list
{
  __pthread_internal_list *__prev;
  __pthread_internal_list *__next;
};

/* 249 */
typedef __pthread_internal_list __pthread_list_t;

/* 248 */
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;
  unsigned int __nusers;
  int __kind;
  __int16 __spins;
  __int16 __elision;
  __pthread_list_t __list;
};

/* 219 */
union pthread_mutex_t
{
  __pthread_mutex_s __data;
  char __size[40];
  __int64 __align;
};

/* 213 */
struct __rtld_lock_recursive_t
{
  pthread_mutex_t mutex;
};

/* 217 */
struct unique_sym_table
{
  __rtld_lock_recursive_t lock;
  unique_sym *entries;
  size_t size;
  size_t n_elements;
  void (*free)(void *);
};

/* 246 */
struct r_debug
{
  int r_version;
  link_map_public *r_map;
  Elf64_Addr r_brk;
  enum : __int32
  {
    RT_CONSISTENT = 0x0,
    RT_ADD = 0x1,
    RT_DELETE = 0x2,
  } r_state;
  Elf64_Addr r_ldbase;
};

/* 216 */
struct r_debug_extended
{
  r_debug base;
  r_debug_extended *r_next;
};

/* 210 */
struct link_namespaces
{
  link_map *_ns_loaded;
  unsigned int _ns_nloaded;
  r_scope_elem *_ns_main_searchlist;
  unsigned int _ns_global_scope_alloc;
  unsigned int _ns_global_scope_pending_adds;
  link_map *libc_map;
  unique_sym_table _ns_unique_sym_table;
  r_debug_extended _ns_debug;
};

/* 218 */
struct unique_sym
{
  uint32_t hashval;
  const char *name;
  const Elf64_Sym_0 *sym;
  const link_map *map;
};

/* 247 */
struct link_map_public
{
  Elf64_Addr l_addr;
  char *l_name;
  Elf64_Dyn_0 *l_ld;
  link_map_public *l_next;
  link_map_public *l_prev;
};

/* 211 */
typedef list_head list_t;

/* 242 */
struct list_head
{
  list_head *next;
  list_head *prev;
};

/* 212 */
struct dl_x86_feature_control
{
  _BYTE gap0[4];
};

/* 214 */
struct dtv_slotinfo
{
  size_t gen;
  link_map *map;
};

/* 215 */
struct dtv_slotinfo_list
{
  size_t len;
  dtv_slotinfo_list *next;
  dtv_slotinfo slotinfo[];
};

/* 220 */
struct priority_protection_data
{
  int priomax;
  unsigned int priomap[];
};

/* 244 */
typedef dtv dtv_t;

/* 243 */
struct __128bits
{
  int i[4];
};

/* 230 */
struct tcbhead_t
{
  void *tcb;
  dtv_t *dtv;
  void *self;
  int multiple_threads;
  int gscope_flag;
  uintptr_t sysinfo;
  uintptr_t stack_guard;
  uintptr_t pointer_guard;
  unsigned __int64 unused_vgetcpu_cache[2];
  unsigned int feature_1;
  int __glibc_unused1;
  void *__private_tm[4];
  void *__private_ss;
  unsigned __int64 ssp_base;
  __128bits __glibc_unused2[8][4];
  void *__padding[8];
};

/* 251 */
typedef int __pid_t;

/* 229 */
typedef __pid_t pid_t;

/* 228 */
struct robust_list_head
{
  void *list;
  __int64 futex_offset;
  void *list_op_pending;
};

/* 222 */
struct pthread_key_data
{
  uintptr_t seq;
  void *data;
};

/* 227 */
typedef unsigned __int64 hp_timing_t;

/* 1059 */
struct td_thr_events
{
  uint32_t event_bits[2];
};

/* 240 */
typedef td_thr_events td_thr_events_t;

/* 239 */
enum td_event_e : __int32
{
  TD_ALL_EVENTS = 0x0,
  TD_EVENT_NONE = 0x0,
  TD_READY = 0x1,
  TD_SLEEP = 0x2,
  TD_SWITCHTO = 0x3,
  TD_SWITCHFROM = 0x4,
  TD_LOCK_TRY = 0x5,
  TD_CATCHSIG = 0x6,
  TD_IDLE = 0x7,
  TD_CREATE = 0x8,
  TD_DEATH = 0x9,
  TD_PREEMPT = 0xA,
  TD_PRI_INHERIT = 0xB,
  TD_REAP = 0xC,
  TD_CONCURRENCY = 0xD,
  TD_TIMEOUT = 0xE,
  TD_MIN_EVENT_NUM = 0x1,
  TD_MAX_EVENT_NUM = 0xE,
  TD_EVENTS_ENABLE = 0x1F,
};

/* 226 */
struct td_eventbuf_t
{
  td_thr_events_t eventmask;
  td_event_e eventnum;
  void *eventdata;
};

/* 225 */
struct __res_state
{
  int retrans;
  int retry;
  unsigned __int64 options;
  int nscount;
  sockaddr_in nsaddr_list[3];
  unsigned __int16 id;
  char *dnsrch[7];
  char defdname[256];
  unsigned __int64 pfcode;
  _BYTE gap188[4];
  struct {in_addr addr;uint32_t mask;}; sort_list[10];
  void *__glibc_unused_qhook;
  void *__glibc_unused_rhook;
  int res_h_errno;
  int _vcsock;
  unsigned int _flags;
  union
  {
    char pad[52];
    struct
    {
      uint16_t nscount;
      uint16_t nsmap[3];
      int nssocks[3];
      uint16_t nscount6;
      uint16_t nsinit;
      sockaddr_in6 *nsaddrs[3];
      unsigned __int64 __glibc_extension_index;
    } _ext;
  } _u;
};

/* 224 */
struct tls_internal_t
{
  char *strsignal_buf;
  char *strerror_l_buf;
};

/* 233 */
typedef unsigned int __u32;

/* 234 */
typedef unsigned __int64 __u64;

/* 223 */
struct __attribute__((aligned(16))) rseq
{
  __u32 cpu_id_start;
  __u32 cpu_id;
  __u64 rseq_cs;
  __u32 flags;
};

/* 221 */
struct pthread
{
  union
  {
    tcbhead_t header;
    void *__padding[24];
  };
  list_t list;
  pid_t tid;
  pid_t pid_ununsed;
  void *robust_prev;
  robust_list_head robust_head;
  _pthread_cleanup_buffer *cleanup;
  pthread_unwind_buf *cleanup_jmp_buf;
  int cancelhandling;
  int flags;
  pthread_key_data specific_1stblock[32];
  pthread_key_data *specific[32];
  bool specific_used;
  bool report_events;
  bool user_stack;
  bool stopped_start;
  int setup_failed;
  int lock;
  unsigned int setxid_futex;
  hp_timing_t cpuclock_offset_ununsed;
  pthread *joinid;
  void *result;
  sched_param schedparam;
  int schedpolicy;
  void *(*start_routine)(void *);
  void *arg;
  td_eventbuf_t eventbuf;
  pthread *nextevent;
  _Unwind_Exception exc;
  void *stackblock;
  size_t stackblock_size;
  size_t guardsize;
  size_t reported_guardsize;
  priority_protection_data *tpp;
  __res_state res;
  sigset_t sigmask;
  bool c11;
  unsigned __int8 cancelstate;
  unsigned __int8 canceltype;
  bool exiting;
  int exit_lock;
  tls_internal_t tls_state;
  __attribute__((aligned(32))) rseq rseq_area;
  char end_padding[];
};

/* 245 */
struct dtv_pointer
{
  void *val;
  void *to_free;
};

/* 920 */
union dtv
{
  size_t counter;
  dtv_pointer pointer;
};

/* 241 */
struct _pthread_cleanup_buffer
{
  void (*__routine)(void *);
  void *__arg;
  int __canceltype;
  _pthread_cleanup_buffer *__prev;
};

/* 232 */
typedef __int64 __jmp_buf[8];

/* 231 */
struct pthread_unwind_buf
{
  struct __attribute__((aligned(8))) {__jmp_buf jmp_buf;int mask_was_saved;}; cancel_jmp_buf[1];
  union
  {
    void *pad[4];
    struct __attribute__((aligned(8)))
    {
      pthread_unwind_buf *prev;
      _pthread_cleanup_buffer *cleanup;
      int canceltype;
    } data;
  } priv;
};

/* 252 */
struct do_dlopen_args
{
  const char *name;
  int mode;
  const void *caller_dlopen;
  link_map *map;
};

/* 253 */
struct do_dlsym_args
{
  link_map *map;
  const char *name;
  lookup_t loadbase;
  const Elf64_Sym_0 *ref;
};

/* 254 */
struct do_dlvsym_args
{
  do_dlsym_args dlsym;
  r_found_version version;
};

/* 255 */
struct __pthread_cleanup_frame
{
  void (*__cancel_routine)(void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};

/* 256 */
struct dl_phdr_info
{
  Elf64_Addr dlpi_addr;
  const char *dlpi_name;
  const Elf64_Phdr *dlpi_phdr;
  Elf64_Half dlpi_phnum;
  unsigned __int64 dlpi_adds;
  unsigned __int64 dlpi_subs;
  size_t dlpi_tls_modid;
  void *dlpi_tls_data;
};

/* 257 */
struct __jmp_buf_tag
{
  __jmp_buf __jmpbuf;
  int __mask_was_saved;
  __sigset_t __saved_mask;
};

/* 259 */
typedef __jmp_buf_tag jmp_buf[1];

/* 258 */
struct catch
{
  dl_exception *exception;
  volatile int *errcode;
  jmp_buf env;
};

/* 266 */
struct exit_status
{
  __int16 e_termination;
  __int16 e_exit;
};

/* 261 */
struct utmp
{
  __int16 ut_type;
  pid_t ut_pid;
  char ut_line[32];
  char ut_id[4];
  char ut_user[32];
  char ut_host[256];
  exit_status ut_exit;
  int32_t ut_session;
  struct
  {
    int32_t tv_sec;
    int32_t tv_usec;
  } ut_tv;
  int32_t ut_addr_v6[4];
  char __glibc_reserved[20];
};

/* 264 */
struct __exit_status
{
  __int16 e_termination;
  __int16 e_exit;
};

/* 263 */
struct utmpx
{
  __int16 ut_type;
  __pid_t ut_pid;
  char ut_line[32];
  char ut_id[4];
  char ut_user[32];
  char ut_host[256];
  __exit_status ut_exit;
  __int32_t ut_session;
  struct
  {
    __int32_t tv_sec;
    __int32_t tv_usec;
  } ut_tv;
  __int32_t ut_addr_v6[4];
  char __glibc_reserved[20];
};

/* 267 */
struct winsize
{
  unsigned __int16 ws_row;
  unsigned __int16 ws_col;
  unsigned __int16 ws_xpixel;
  unsigned __int16 ws_ypixel;
};

/* 268 */
typedef unsigned __int8 cc_t;

/* 271 */
typedef unsigned int tcflag_t;

/* 270 */
typedef unsigned int speed_t;

/* 269 */
struct termios
{
  tcflag_t c_iflag;
  tcflag_t c_oflag;
  tcflag_t c_cflag;
  tcflag_t c_lflag;
  cc_t c_line;
  cc_t c_cc[32];
  speed_t c_ispeed;
  speed_t c_ospeed;
};

/* 274 */
typedef void (*__sighandler_t)(int);

/* 272 */
struct sigaction
{
  union
  {
    __sighandler_t sa_handler;
    void (*sa_sigaction)(int, siginfo_t *, void *);
  } __sigaction_handler;
  __sigset_t sa_mask;
  int sa_flags;
  void (*sa_restorer)(void);
};

/* 278 */
union sigval
{
  int sival_int;
  void *sival_ptr;
};

/* 277 */
typedef sigval __sigval_t;

/* 275 */
typedef __int64 __clock_t;

/* 273 */
struct siginfo_t
{
  int si_signo;
  int si_errno;
  int si_code;
  int __pad0;
  union
  {
    int _pad[28];
    struct
    {
      __pid_t si_pid;
      __uid_t si_uid;
    } _kill;
    struct
    {
      int si_tid;
      int si_overrun;
      __sigval_t si_sigval;
    } _timer;
    struct
    {
      __pid_t si_pid;
      __uid_t si_uid;
      __sigval_t si_sigval;
    } _rt;
    struct
    {
      __pid_t si_pid;
      __uid_t si_uid;
      int si_status;
      __clock_t si_utime;
      __clock_t si_stime;
    } _sigchld;
    struct
    {
      void *si_addr;
      __int16 si_addr_lsb;
      union
      {
        struct
        {
          void *_lower;
          void *_upper;
        } _addr_bnd;
        __uint32_t _pkey;
      } _bounds;
    } _sigfault;
    struct __attribute__((aligned(8)))
    {
      __int64 si_band;
      int si_fd;
    } _sigpoll;
    struct
    {
      void *_call_addr;
      int _syscall;
      unsigned int _arch;
    } _sigsys;
  } _sifields;
};

/* 281 */
struct max_align_t
{
  __int64 __max_align_ll;
  long double __max_align_ld;
};

/* 280 */
struct scratch_buffer
{
  void *data;
  size_t length;
  union
  {
    max_align_t __align;
    char __c[1024];
  } __space;
};

/* 283 */
struct iovec
{
  void *iov_base;
  size_t iov_len;
};

/* 284 */
struct pollfd
{
  int fd;
  __int16 events;
  __int16 revents;
};

/* 286 */
enum request_type : __int32
{
  GETPWBYNAME = 0x0,
  GETPWBYUID = 0x1,
  GETGRBYNAME = 0x2,
  GETGRBYGID = 0x3,
  GETHOSTBYNAME = 0x4,
  GETHOSTBYNAMEv6 = 0x5,
  GETHOSTBYADDR = 0x6,
  GETHOSTBYADDRv6 = 0x7,
  SHUTDOWN = 0x8,
  GETSTAT = 0x9,
  INVALIDATE = 0xA,
  GETFDPW = 0xB,
  GETFDGR = 0xC,
  GETFDHST = 0xD,
  GETAI = 0xE,
  INITGROUPS = 0xF,
  GETSERVBYNAME = 0x10,
  GETSERVBYPORT = 0x11,
  GETFDSERV = 0x12,
  GETNETGRENT = 0x13,
  INNETGR = 0x14,
  GETFDNETGR = 0x15,
  LASTREQ = 0x16,
};

/* 285 */
struct request_header
{
  int32_t version;
  request_type type;
  int32_t key_len;
};

/* 298 */
typedef uint64_t nscd_time_t;

/* 296 */
typedef int32_t nscd_ssize_t;

/* 295 */
typedef uint32_t ref_t;

/* 287 */
struct database_pers_head
{
  int32_t version;
  int32_t header_size;
  volatile int32_t gc_cycle;
  volatile int32_t nscd_certainly_running;
  volatile nscd_time_t timestamp;
  volatile uint32_t extra_data[4];
  nscd_ssize_t module;
  nscd_ssize_t data_size;
  nscd_ssize_t first_free;
  nscd_ssize_t nentries;
  nscd_ssize_t maxnentries;
  nscd_ssize_t maxnsearched;
  uint64_t poshit;
  uint64_t neghit;
  uint64_t posmiss;
  uint64_t negmiss;
  uint64_t rdlockdelayed;
  uint64_t wrlockdelayed;
  uint64_t addfailed;
  ref_t array[];
};

/* 288 */
struct cmsghdr
{
  size_t cmsg_len;
  int cmsg_level;
  int cmsg_type;
  unsigned __int8 __cmsg_data[];
};

/* 308 */
typedef __uid_t uid_t;

/* 307 */
typedef __gid_t gid_t;

/* 306 */
struct pw_response_header
{
  int32_t version;
  int32_t found;
  nscd_ssize_t pw_name_len;
  nscd_ssize_t pw_passwd_len;
  uid_t pw_uid;
  gid_t pw_gid;
  nscd_ssize_t pw_gecos_len;
  nscd_ssize_t pw_dir_len;
  nscd_ssize_t pw_shell_len;
};

/* 305 */
struct gr_response_header
{
  int32_t version;
  int32_t found;
  nscd_ssize_t gr_name_len;
  nscd_ssize_t gr_passwd_len;
  gid_t gr_gid;
  nscd_ssize_t gr_mem_cnt;
};

/* 304 */
struct hst_response_header
{
  int32_t version;
  int32_t found;
  nscd_ssize_t h_name_len;
  nscd_ssize_t h_aliases_cnt;
  int32_t h_addrtype;
  int32_t h_length;
  nscd_ssize_t h_addr_list_cnt;
  int32_t error;
};

/* 303 */
struct ai_response_header
{
  int32_t version;
  int32_t found;
  nscd_ssize_t naddrs;
  nscd_ssize_t addrslen;
  nscd_ssize_t canonlen;
  int32_t error;
};

/* 302 */
struct initgr_response_header
{
  int32_t version;
  int32_t found;
  nscd_ssize_t ngrps;
};

/* 301 */
struct serv_response_header
{
  int32_t version;
  int32_t found;
  nscd_ssize_t s_name_len;
  nscd_ssize_t s_proto_len;
  nscd_ssize_t s_aliases_cnt;
  int32_t s_port;
};

/* 300 */
struct netgroup_response_header
{
  int32_t version;
  int32_t found;
  nscd_ssize_t nresults;
  nscd_ssize_t result_len;
};

/* 299 */
struct innetgroup_response_header
{
  int32_t version;
  int32_t found;
  int32_t result;
};

/* 289 */
struct datahead
{
  nscd_ssize_t allocsize;
  nscd_ssize_t recsize;
  nscd_time_t timeout;
  uint8_t notfound;
  uint8_t nreloads;
  uint8_t usable;
  uint8_t unused;
  uint32_t ttl;
  union __attribute__((aligned(8))) {pw_response_header pwdata;gr_response_header grdata;hst_response_header hstdata;ai_response_header aidata;initgr_response_header initgrdata;serv_response_header servdata;netgroup_response_header netgroupdata;innetgroup_response_header innetgroupdata;nscd_ssize_t align1;nscd_time_t align2;}; data[];
};

/* 291 */
typedef __socklen_t socklen_t;

/* 290 */
struct __attribute__((aligned(8))) msghdr
{
  void *msg_name;
  socklen_t msg_namelen;
  iovec *msg_iov;
  size_t msg_iovlen;
  void *msg_control;
  size_t msg_controllen;
  int msg_flags;
};

/* 292 */
typedef void __CONST_SOCKADDR_ARG;

/* 293 */
struct mapped_database
{
  const database_pers_head *head;
  const char *data;
  size_t mapsize;
  int counter;
  size_t datasize;
};

/* 294 */
struct locked_map_ptr
{
  int lock;
  mapped_database *mapped;
};

/* 297 */
struct hashentry
{
  _BYTE gap0;
  bool first;
  nscd_ssize_t len;
  ref_t key;
  int32_t owner;
  ref_t next;
  ref_t packet;
  union
  {
    hashentry *dellist;
    ref_t *prevp;
  };
};

/* 384 */
struct nscd_ai_result
{
  int naddrs;
  char *canon;
  uint8_t *family;
  char *addrs;
};

/* 385 */
struct rpc_createerr
{
  clnt_stat cf_stat;
  rpc_err cf_error;
};

/* 417 */
typedef __int64 __quad_t;

/* 410 */
typedef __quad_t quad_t;

/* 416 */
typedef unsigned __int64 __u_quad_t;

/* 411 */
typedef __u_quad_t u_quad_t;

/* 414 */
typedef __int16 __int16_t;

/* 412 */
typedef __int16_t int16_t;

/* 415 */
typedef char __int8_t;

/* 413 */
typedef __int8_t int8_t;

/* 424 */
typedef unsigned __int8 __u_char;

/* 419 */
typedef __u_char u_char;

/* 420 */
struct netobj
{
  u_int n_len;
  char *n_bytes;
};

/* 422 */
struct xdr_discrim
{
  int value;
  xdrproc_t proc;
};

/* 425 */
struct in_pktinfo
{
  int ipi_ifindex;
  in_addr ipi_spec_dst;
  in_addr ipi_addr;
};

/* 426 */
struct udp_cache
{
  u_long uc_size;
  cache_ptr *uc_entries;
  cache_ptr *uc_fifo;
  u_long uc_nextvictim;
  u_long uc_prog;
  u_long uc_vers;
  u_long uc_proc;
  sockaddr_in uc_addr;
};

/* 427 */
struct svcudp_data
{
  u_int su_iosz;
  u_long su_xid;
  XDR su_xdrs;
  char su_verfbody[400];
  char *su_cache;
};

/* 428 */
typedef void __SOCKADDR_ARG;

/* 441 */
struct tcp_rendezvous
{
  u_int sendsize;
  u_int recvsize;
};

/* 442 */
struct tcp_conn
{
  xprt_stat strm_stat;
  u_long x_id;
  XDR xdrs;
  char verf_body[400];
};

/* 444 */
typedef unsigned __int64 rpcvers_t;

/* 445 */
typedef unsigned __int64 rpcprog_t;

/* 446 */
typedef unsigned __int64 rpcproc_t;

/* 458 */
typedef __int64 __fd_mask;

/* 447 */
typedef __fd_mask fd_mask;

/* 448 */
struct fd_set
{
  __fd_mask fds_bits[16];
};

/* 449 */
struct rpc_thread_variables
{
  fd_set svc_fdset_s;
  rpc_createerr rpc_createerr_s;
  pollfd *svc_pollfd_s;
  int svc_max_pollfd_s;
  char *clnt_perr_buf_s;
  clntraw_private_s *clntraw_private_s;
  callrpc_private_s *callrpc_private_s;
  key_call_private *key_call_private_s;
  cache_entry *authdes_cache_s;
  int *authdes_lru_s;
  SVCXPRT **svc_xports_s;
  svc_callout *svc_head_s;
  svcraw_private_s *svcraw_private_s;
  proglst_ *svcsimple_proglst_s;
  SVCXPRT *svcsimple_transp_s;
};

/* 456 */
struct __attribute__((aligned(8))) clntraw_private_s
{
  CLIENT client_object;
  XDR xdr_stream;
  char _raw_buf[8800];
  union
  {
    char msg[24];
    u_long rm_xid;
  } mashl_callmsg;
  u_int mcnt;
};

/* 455 */
struct callrpc_private_s
{
  CLIENT *client;
  int socket;
  u_long oldprognum;
  u_long oldversnum;
  u_long valid;
  char *oldhost;
};

/* 454 */
struct key_call_private
{
  CLIENT *client;
  pid_t pid;
  uid_t uid;
};

/* 486 */
struct rpc_timeval
{
  uint32_t tv_sec;
  uint32_t tv_usec;
};

/* 453 */
struct cache_entry
{
  des_block key;
  char *rname;
  u_int window;
  rpc_timeval laststamp;
  char *localcred;
};

/* 452 */
struct __attribute__((aligned(8))) svc_callout
{
  svc_callout *sc_next;
  rpcprog_t sc_prog;
  rpcvers_t sc_vers;
  void (*sc_dispatch)(svc_req *, SVCXPRT *);
  bool_t sc_mapped;
};

/* 451 */
struct svcraw_private_s
{
  char _raw_buf[8800];
  SVCXPRT server;
  XDR xdr_stream;
  char verf_body[400];
};

/* 450 */
struct proglst_
{
  char *(*p_progname)(char *);
  int p_prognum;
  int p_procnum;
  xdrproc_t p_inproc;
  xdrproc_t p_outproc;
  proglst_ *p_nxt;
};

/* 457 */
struct svc_req
{
  rpcprog_t rq_prog;
  rpcvers_t rq_vers;
  rpcproc_t rq_proc;
  opaque_auth rq_cred;
  caddr_t rq_clntcred;
  SVCXPRT *rq_xprt;
};

/* 459 */
typedef int pthread_once_t;

/* 460 */
struct pmap
{
  unsigned __int64 pm_prog;
  unsigned __int64 pm_vers;
  unsigned __int64 pm_prot;
  unsigned __int64 pm_port;
};

/* 464 */
typedef int (*netname2user_function)(const char *, uid_t *, gid_t *, int *, gid_t *);

/* 468 */
typedef char keybuf[48];

/* 467 */
typedef char *netnamestr;

/* 465 */
struct key_netstarg
{
  keybuf st_priv_key;
  keybuf st_pub_key;
  netnamestr st_netname;
};

/* 472 */
enum keystatus : __int32
{
  keystatus::KEY_SUCCESS = 0x0,
  keystatus::KEY_NOSECRET = 0x1,
  keystatus::KEY_UNKNOWN = 0x2,
  keystatus::KEY_SYSTEMERR = 0x3,
};

/* 466 */
struct key_netstres
{
  keystatus status;
  union
  {
    key_netstarg knet;
  } key_netstres_u;
};

/* 469 */
struct cryptkeyres
{
  keystatus status;
  union
  {
    des_block deskey;
  } cryptkeyres_u;
};

/* 470 */
struct cryptkeyarg2
{
  netnamestr remotename;
  netobj remotekey;
  des_block deskey;
};

/* 471 */
struct cryptkeyarg
{
  netnamestr remotename;
  des_block deskey;
};

/* 473 */
struct ifaddrs
{
  ifaddrs *ifa_next;
  char *ifa_name;
  unsigned int ifa_flags;
  sockaddr *ifa_addr;
  sockaddr *ifa_netmask;
  union
  {
    sockaddr *ifu_broadaddr;
    sockaddr *ifu_dstaddr;
  } ifa_ifu;
  void *ifa_data;
};

/* 474 */
struct deadline
{
  timespec absolute;
};

/* 475 */
struct deadline_current_time
{
  timespec current;
};

/* 476 */
struct sock_extended_err
{
  uint32_t ee_errno;
  uint8_t ee_origin;
  uint8_t ee_type;
  uint8_t ee_code;
  uint8_t ee_pad;
  uint32_t ee_info;
  uint32_t ee_data;
};

/* 477 */
struct __attribute__((aligned(4))) cu_data
{
  int cu_sock;
  bool_t cu_closeit;
  sockaddr_in cu_raddr;
  int cu_rlen;
  timeval cu_wait;
  timeval cu_total;
  rpc_err cu_error;
  XDR cu_outxdrs;
  u_int cu_xdrpos;
  u_int cu_sendsz;
  char *cu_outbuf;
  u_int cu_recvsz;
  char cu_inbuf[1];
};

/* 478 */
struct ct_data
{
  int ct_sock;
  bool_t ct_closeit;
  timeval ct_wait;
  bool_t ct_waitset;
  sockaddr_in ct_addr;
  rpc_err ct_error;
  char ct_mcall[24];
  u_int ct_mpos;
  XDR ct_xdrs;
};

/* 479 */
struct auth_errtab
{
  auth_stat status;
  unsigned int message_off;
};

/* 480 */
struct rpc_errtab
{
  clnt_stat status;
  unsigned int message_off;
};

/* 481 */
struct __attribute__((aligned(8))) audata
{
  opaque_auth au_origcred;
  opaque_auth au_shcred;
  u_long au_shfaults;
  char au_marshed[400];
  u_int au_mpos;
};

/* 482 */
struct authunix_parms
{
  u_long aup_time;
  char *aup_machname;
  __uid_t aup_uid;
  __gid_t aup_gid;
  u_int aup_len;
  __gid_t *aup_gids;
};

/* 488 */
enum authdes_namekind : __int32
{
  authdes_namekind::ADN_FULLNAME = 0x0,
  authdes_namekind::ADN_NICKNAME = 0x1,
};

/* 487 */
struct __attribute__((aligned(8))) authdes_fullname
{
  char *name;
  des_block key;
  uint32_t window;
};

/* 484 */
struct __attribute__((aligned(8))) authdes_cred
{
  authdes_namekind adc_namekind;
  authdes_fullname adc_fullname;
  uint32_t adc_nickname;
};

/* 485 */
struct authdes_verf
{
  union
  {
    rpc_timeval adv_ctime;
    des_block adv_xtime;
  } adv_time_u;
  uint32_t adv_int_u;
};

/* 483 */
struct __attribute__((aligned(8))) ad_private
{
  char *ad_fullname;
  u_int ad_fullnamelen;
  char *ad_servername;
  u_int ad_servernamelen;
  uint32_t ad_window;
  bool_t ad_dosync;
  sockaddr ad_syncaddr;
  rpc_timeval ad_timediff;
  uint32_t ad_nickname;
  authdes_cred ad_cred;
  authdes_verf ad_verf;
  rpc_timeval ad_timestamp;
  des_block ad_xkey;
  u_char ad_pkey[1024];
};

/* 489 */
struct drand48_data
{
  unsigned __int16 __x[3];
  unsigned __int16 __old_x[3];
  unsigned __int16 __c;
  unsigned __int16 __init;
  unsigned __int64 __a;
};

/* 490 */
typedef __int64 __intptr_t;

/* 491 */
struct unix_rendezvous
{
  u_int sendsize;
  u_int recvsize;
};

/* 492 */
struct unix_conn
{
  xprt_stat strm_stat;
  u_long x_id;
  XDR xdrs;
  char verf_body[400];
};

/* 493 */
struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};

/* 494 */
struct _svcauth_des::area
{
  authdes_cred area_cred;
  char area_netname[256];
};

/* 495 */
struct bsdcred
{
  uid_t uid;
  gid_t gid;
  int grouplen;
  int grouplen_max;
  gid_t groups[];
};

/* 497 */
struct unixcred
{
  u_int uid;
  u_int gid;
  struct
  {
    u_int gids_len;
    u_int *gids_val;
  } gids;
};

/* 496 */
struct getcredres
{
  keystatus status;
  union
  {
    unixcred cred;
  } getcredres_u;
};

/* 500 */
enum desdir : __int32
{
  desdir::ENCRYPT = 0x0,
  desdir::DECRYPT = 0x1,
};

/* 499 */
enum desmode : __int32
{
  desmode::CBC = 0x0,
  desmode::ECB = 0x1,
};

/* 498 */
struct desparams
{
  unsigned __int8 des_key[8];
  desdir des_dir;
  desmode des_mode;
  unsigned __int8 des_ivec[8];
  unsigned int des_len;
  union
  {
    unsigned __int8 UDES_data[16];
    unsigned __int8 *UDES_buf;
  } UDES;
};

/* 501 */
typedef int (*public_function)(const char *, char *, int *);

/* 502 */
typedef int (*secret_function)(const char *, char *, const char *, int *);

/* 503 */
typedef rec_strm RECSTREAM;

/* 1060 */
struct __attribute__((aligned(8))) rec_strm
{
  caddr_t tcp_handle;
  caddr_t the_buffer;
  int (*writeit)(char *, char *, int);
  caddr_t out_base;
  caddr_t out_finger;
  caddr_t out_boundry;
  uint32_t *frag_header;
  bool_t frag_sent;
  int (*readit)(char *, char *, int);
  u_long in_size;
  caddr_t in_base;
  caddr_t in_finger;
  caddr_t in_boundry;
  __int64 fbtbc;
  bool_t last_frag;
  u_int sendsize;
  u_int recvsize;
};

/* 504 */
typedef unsigned __int64 rpcprot_t;

/* 505 */
typedef void (*__dispatch_fn_t)(svc_req *, SVCXPRT *);

/* 506 */
struct _svcauth_unix::area
{
  authunix_parms area_aup;
  char area_machname[256];
  gid_t area_gids[16];
};

/* 507 */
struct rmtcallargs
{
  u_long prog;
  u_long vers;
  u_long proc;
  u_long arglen;
  caddr_t args_ptr;
  xdrproc_t xdr_args;
};

/* 508 */
struct rmtcallres
{
  u_long *port_ptr;
  u_long resultslen;
  caddr_t results_ptr;
  xdrproc_t xdr_results;
};

/* 509 */
typedef bool_t (*resultproc_t)(caddr_t, sockaddr_in *);

/* 510 */
struct pmaplist
{
  pmap pml_map;
  pmaplist *pml_next;
};

/* 511 */
struct authnone_private_s
{
  AUTH no_client;
  char marshalled_client[20];
  u_int mcnt;
};

/* 512 */
typedef _G_fpos_t __fpos_t;

/* 1088 */
struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
};

/* 513 */
enum nss_files_file : __int32
{
  nss_files_file::nss_file_aliasent = 0x0,
  nss_files_file::nss_file_etherent = 0x1,
  nss_files_file::nss_file_grent = 0x2,
  nss_files_file::nss_file_hostent = 0x3,
  nss_files_file::nss_file_netent = 0x4,
  nss_files_file::nss_file_protoent = 0x5,
  nss_files_file::nss_file_pwent = 0x6,
  nss_files_file::nss_file_rpcent = 0x7,
  nss_files_file::nss_file_servent = 0x8,
  nss_files_file::nss_file_sgent = 0x9,
  nss_files_file::nss_file_spent = 0xA,
  nss_files_file::nss_file_count = 0xB,
};

/* 514 */
struct __attribute__((aligned(8))) nss_files_per_file_data
{
  FILE *stream;
  __libc_lock_t lock;
};

/* 517 */
struct hostent_data
{
  unsigned __int8 host_addr[16];
  char *h_addr_ptrs[2];
};

/* 520 */
struct dynarray_header
{
  size_t used;
  size_t allocated;
  void *array;
};

/* 518 */
struct array
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      char **array;
    } dynarray_header;
  } u;
  char *scratch[16];
};

/* 519 */
struct alloc_buffer
{
  uintptr_t __alloc_buffer_current;
  uintptr_t __alloc_buffer_end;
};

/* 521 */
struct nss_files_data
{
  nss_files_per_file_data files[11];
};

/* 522 */
enum nss_database : __int32
{
  nss_database::nss_database_aliases = 0x0,
  nss_database::nss_database_ethers = 0x1,
  nss_database::nss_database_group = 0x2,
  nss_database::nss_database_group_compat = 0x3,
  nss_database::nss_database_gshadow = 0x4,
  nss_database::nss_database_hosts = 0x5,
  nss_database::nss_database_initgroups = 0x6,
  nss_database::nss_database_netgroup = 0x7,
  nss_database::nss_database_networks = 0x8,
  nss_database::nss_database_passwd = 0x9,
  nss_database::nss_database_passwd_compat = 0xA,
  nss_database::nss_database_protocols = 0xB,
  nss_database::nss_database_publickey = 0xC,
  nss_database::nss_database_rpc = 0xD,
  nss_database::nss_database_services = 0xE,
  nss_database::nss_database_shadow = 0xF,
  nss_database::nss_database_shadow_compat = 0x10,
  nss_database::NSS_DATABASE_COUNT = 0x11,
};

/* 523 */
typedef int (*__compar_fn_t)(const void *, const void *);

/* 526 */
typedef nss_action *nss_action_list;

/* 524 */
struct nss_database_default_cache
{
  nss_action_list caches[7];
};

/* 525 */
typedef char database_name[14];

/* 529 */
struct file_change_detection
{
  off64_t size;
  ino64_t ino;
  timespec mtime;
  timespec ctime;
};

/* 528 */
struct __attribute__((aligned(4))) nss_database_data
{
  file_change_detection nsswitch_conf;
  nss_action_list services[17];
  int reload_disabled;
  bool initialized;
};

/* 527 */
struct nss_database_state
{
  nss_database_data data;
  __libc_lock_t lock;
  ino64_t root_ino;
  dev_t root_dev;
};

/* 530 */
enum lookup_actions : __int32
{
  NSS_ACTION_CONTINUE = 0x0,
  NSS_ACTION_RETURN = 0x1,
  NSS_ACTION_MERGE = 0x2,
};

/* 531 */
struct action_list
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      nss_action *array;
    } dynarray_header;
  } u;
  nss_action scratch[8];
};

/* 532 */
struct nss_action_list_wrapper
{
  nss_action_list_wrapper *next;
  size_t count;
  nss_action actions[];
};

/* 533 */
typedef char function_name[19];

/* 534 */
typedef int nss_files_parse_line(char *, void *, parser_data *, size_t, int *);

/* 535 */
typedef char *__nss_hostname_digits_dots_context::host_addr_list_t[2];

/* 536 */
typedef unsigned __int8 __nss_hostname_digits_dots_context::host_addr_t[16];

/* 537 */
struct resolv_context
{
  __res_state *resp;
  resolv_conf *conf;
  size_t __refcount;
  bool __from_res;
  resolv_context *__next;
};

/* 538 */
struct resolv_conf
{
  size_t __refcount;
  const sockaddr **nameserver_list;
  size_t nameserver_list_size;
  const char *const *search_list;
  size_t search_list_size;
  const resolv_sortlist_entry *sort_list;
  size_t sort_list_size;
  unsigned int options;
  unsigned int retrans;
  unsigned int retry;
  unsigned int ndots;
};

/* 539 */
struct resolv_sortlist_entry
{
  in_addr addr;
  uint32_t mask;
};

/* 540 */
typedef int (*db_lookup_function)(nss_action **, const char *, const char *, void **);

/* 541 */
typedef nss_status (*setent_function)(int);

/* 542 */
typedef nss_status (*endent_function)(void);

/* 543 */
typedef nss_status (*getent_function)(void *, char *, size_t, int *, int *);

/* 544 */
typedef int (*getent_r_function)(void *, char *, size_t, void **, int *);

/* 547 */
struct sigevent
{
  __sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
  union
  {
    int _pad[12];
    __pid_t _tid;
    struct
    {
      void (*_function)(__sigval_t);
      pthread_attr_t *_attribute;
    } _sigev_thread;
  } _sigev_un;
};

/* 1061 */
struct __attribute__((aligned(8))) waitlist_0
{
  waitlist *next;
  volatile unsigned int *counterp;
  sigevent *sigevp;
  pid_t caller_pid;
};

/* 545 */
struct async_waitlist
{
  unsigned int counter;
  sigevent sigev;
  waitlist_0 list[];
};

/* 546 */
struct waitlist
{
  waitlist *next;
  int *result;
  volatile unsigned int *counterp;
  sigevent *sigevp;
};

/* 548 */
struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const addrinfo *ar_request;
  addrinfo *ar_result;
  int __return;
  int __glibc_reserved[5];
};

/* 550 */
struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  sockaddr *ai_addr;
  char *ai_canonname;
  addrinfo *ai_next;
};

/* 549 */
struct requestlist
{
  int running;
  requestlist *next;
  gaicb *gaicbp;
  waitlist *waiting;
};

/* 553 */
typedef __sigval_t sigval_t;

/* 551 */
struct notify_func
{
  void (*func)(sigval_t);
  sigval_t value;
};

/* 552 */
typedef unsigned __int64 pthread_t;

/* 556 */
union __atomic_wide_counter
{
  unsigned __int64 __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
};

/* 555 */
struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2];
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

/* 554 */
union pthread_cond_t
{
  __pthread_cond_s __data;
  char __size[48];
  __int64 __align;
};

/* 557 */
typedef __res_state *res_state;

/* 558 */
struct resolv_conf_array
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      uintptr_t *array;
    } dynarray_header;
  } u;
};

/* 559 */
struct resolv_conf_global
{
  resolv_conf_array array;
  uintptr_t free_list_start;
  resolv_conf *conf_current;
  file_change_detection file_resolve_conf;
};

/* 560 */
typedef HEADER UHEADER;

/* 573 */
struct HEADER
{
  _BYTE gap0[12];
};

/* 1062 */
struct __attribute__((aligned(8))) msghdr_0
{
  void *msg_name;
  socklen_t msg_namelen;
  iovec *msg_iov;
  size_t msg_iovlen;
  void *msg_control;
  size_t msg_controllen;
  int msg_flags;
};

/* 561 */
struct __attribute__((aligned(8))) mmsghdr
{
  msghdr_0 msg_hdr;
  unsigned int msg_len;
};

/* 562 */
struct nameserver_list
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      const sockaddr **array;
    } dynarray_header;
  } u;
  const sockaddr *scratch[3];
};

/* 563 */
struct search_list
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      const char **array;
    } dynarray_header;
  } u;
  const char *scratch[6];
};

/* 564 */
struct sort_list
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      resolv_sortlist_entry *array;
    } dynarray_header;
  } u;
};

/* 565 */
struct resolv_conf_parser
{
  char *buffer;
  nameserver_list nameserver_list;
  char *search_list_store;
  search_list search_list;
  sort_list sort_list;
  resolv_conf template;
};

/* 566 */
struct netaddr
{
  int addrtype;
  union
  {
    struct
    {
      uint32_t addr;
      uint32_t mask;
    } ipv4;
  } u;
};

/* 567 */
struct cmd
{
  const char name[11];
  uint8_t cb;
  unsigned int arg;
};

/* 569 */
struct __attribute__((aligned(4))) ifmap
{
  unsigned __int64 mem_start;
  unsigned __int64 mem_end;
  unsigned __int16 base_addr;
  unsigned __int8 irq;
  unsigned __int8 dma;
  unsigned __int8 port;
};

/* 568 */
struct ifreq
{
  union
  {
    char ifrn_name[16];
  } ifr_ifrn;
  union
  {
    sockaddr ifru_addr;
    sockaddr ifru_dstaddr;
    sockaddr ifru_broadaddr;
    sockaddr ifru_netmask;
    sockaddr ifru_hwaddr;
    __int16 ifru_flags;
    int ifru_ivalue;
    int ifru_mtu;
    ifmap ifru_map;
    char ifru_slave[16];
    char ifru_newname[16];
    __caddr_t ifru_data;
  } ifr_ifru;
};

/* 570 */
struct getanswer_r::net_data
{
  char *aliases[48];
  char linebuffer[];
};

/* 571 */
enum lookup_method : __int32
{
  BYADDR = 0x0,
  BYNAME = 0x1,
};

/* 572 */
union querybuf
{
  HEADER hdr;
  u_char buf[65536];
};

/* 574 */
struct _nss_dns_gethostbyaddr2_r::host_data
{
  char *aliases[48];
  unsigned __int8 host_addr[16];
  char *h_addr_ptrs[49];
  char linebuffer[];
};

/* 575 */
struct getanswer_r::host_data
{
  char *aliases[48];
  unsigned __int8 host_addr[16];
  char *h_addr_ptrs[];
};

/* 576 */
struct ifinfomsg
{
  unsigned __int8 ifi_family;
  unsigned __int8 __ifi_pad;
  unsigned __int16 ifi_type;
  int ifi_index;
  unsigned int ifi_flags;
  unsigned int ifi_change;
};

/* 577 */
struct rtgenmsg
{
  unsigned __int8 rtgen_family;
};

/* 578 */
struct nlmsghdr
{
  __u32 nlmsg_len;
  __u16 nlmsg_type;
  __u16 nlmsg_flags;
  __u32 nlmsg_seq;
  __u32 nlmsg_pid;
};

/* 580 */
struct rtattr
{
  unsigned __int16 rta_len;
  unsigned __int16 rta_type;
};

/* 581 */
struct ifaddrmsg
{
  __u8 ifa_family;
  __u8 ifa_prefixlen;
  __u8 ifa_flags;
  __u8 ifa_scope;
  __u32 ifa_index;
};

/* 582 */
struct in6addrinfo
{
  _BYTE gap0;
  uint8_t prefixlen;
  uint32_t index;
  uint32_t addr[4];
};

/* 583 */
struct cached_data
{
  uint32_t timestamp;
  uint32_t usecnt;
  bool seen_ipv4;
  bool seen_ipv6;
  size_t in6ailen;
  in6addrinfo in6ai[];
};

/* 584 */
typedef __mbstate_t mbstate_t;

/* 585 */
struct functions
{
  void *handle;
  int (*lookup_ul)(const char *, char **, int);
  int (*to_unicode_lzlz)(const char *, char **, int);
};

/* 586 */
typedef unsigned __int64 __uintmax_t;

/* 1048 */
typedef __locale_struct *__locale_t;

/* 587 */
typedef __locale_t locale_t;

/* 592 */
struct __locale_struct
{
  __locale_data *__locales[13];
  const unsigned __int16 *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;
  const char *__names[13];
};

/* 593 */
struct ip6_rthdr0
{
  uint8_t ip6r0_nxt;
  uint8_t ip6r0_len;
  uint8_t ip6r0_type;
  uint8_t ip6r0_segleft;
  uint8_t ip6r0_reserved;
  uint8_t ip6r0_slmap[3];
  in6_addr ip6r0_addr[];
};

/* 594 */
struct ip6_rthdr
{
  uint8_t ip6r_nxt;
  uint8_t ip6r_len;
  uint8_t ip6r_type;
  uint8_t ip6r_segleft;
};

/* 595 */
struct ip6_hbh
{
  uint8_t ip6h_nxt;
  uint8_t ip6h_len;
};

/* 596 */
struct ip6_opt
{
  uint8_t ip6o_type;
  uint8_t ip6o_len;
};

/* 598 */
struct sockaddr_storage
{
  sa_family_t ss_family;
  char __ss_padding[118];
  unsigned __int64 __ss_align;
};

/* 597 */
struct group_filter
{
  uint32_t gf_interface;
  sockaddr_storage gf_group;
  uint32_t gf_fmode;
  uint32_t gf_numsrc;
  sockaddr_storage gf_slist[1];
};

/* 600 */
struct ip_msfilter
{
  in_addr imsf_multiaddr;
  in_addr imsf_interface;
  uint32_t imsf_fmode;
  uint32_t imsf_numsrc;
  in_addr imsf_slist[1];
};

/* 601 */
struct ip6_ext
{
  uint8_t ip6e_nxt;
  uint8_t ip6e_len;
};

/* 602 */
struct nlmsgerr
{
  int error;
  nlmsghdr msg;
};

/* 603 */
struct netlink_handle
{
  int fd;
  pid_t pid;
  uint32_t seq;
  netlink_res *nlm_list;
  netlink_res *end_ptr;
};

/* 606 */
struct __attribute__((aligned(8))) netlink_res
{
  netlink_res *next;
  nlmsghdr *nlh;
  size_t size;
  uint32_t seq;
};

/* 605 */
struct sockaddr_ll_max
{
  unsigned __int16 sll_family;
  unsigned __int16 sll_protocol;
  int sll_ifindex;
  unsigned __int16 sll_hatype;
  unsigned __int8 sll_pkttype;
  unsigned __int8 sll_halen;
  unsigned __int8 sll_addr[24];
};

/* 604 */
struct __attribute__((aligned(4))) ifaddrs_storage
{
  ifaddrs ifa;
  union
  {
    sockaddr sa;
    sockaddr_ll_max sl;
    sockaddr_in s4;
    sockaddr_in6 s6;
  } addr;
  union
  {
    sockaddr sa;
    sockaddr_ll_max sl;
    sockaddr_in s4;
    sockaddr_in6 s6;
  } netmask;
  union
  {
    sockaddr sa;
    sockaddr_ll_max sl;
    sockaddr_in s4;
    sockaddr_in6 s6;
  } broadaddr;
  char name[17];
};

/* 607 */
struct if_nameindex
{
  unsigned int if_index;
  char *if_name;
};

/* 608 */
struct utsname
{
  char sysname[65];
  char nodename[65];
  char release[65];
  char version[65];
  char machine[65];
  char domainname[65];
};

/* 609 */
typedef int (*lookup_function)(const char *, etherent *, char *, int, int *);

/* 610 */
struct toktab
{
  int tokstr_off;
  int tval;
};

/* 611 */
enum __libc_message_action : __int32
{
  __libc_message_action::do_message = 0x0,
  __libc_message_action::do_abort = 0x1,
};

/* 612 */
typedef unsigned __int64 nfds_t;

/* 614 */
struct __jmp_buf_sigset_t
{
  unsigned __int64 __val[2];
};

/* 613 */
union __jmpbuf_arch_t
{
  __sigset_t __saved_mask_compat;
  struct
  {
    __jmp_buf_sigset_t __saved_mask;
    unsigned __int64 __shadow_stack_pointer;
  } __saved;
};

/* 615 */
typedef __builtin_va_list __gnuc_va_list;

/* 616 */
struct trace_arg
{
  void **array;
  unwind_link *unwind_link;
  _Unwind_Word cfa;
  int cnt;
  int size;
};

/* 620 */
typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn)(struct _Unwind_Context *, void *);

/* 621 */
typedef int _Unwind_Action;

/* 619 */
typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)(int, _Unwind_Action, _Unwind_Exception_Class, _Unwind_Exception *, struct _Unwind_Context *, void *);

/* 618 */
typedef unsigned __int64 _Unwind_Ptr;

/* 617 */
struct unwind_link
{
  _Unwind_Reason_Code (*ptr__Unwind_Backtrace)(_Unwind_Trace_Fn, void *);
  _Unwind_Reason_Code (*ptr__Unwind_ForcedUnwind)(_Unwind_Exception *, _Unwind_Stop_Fn, void *);
  _Unwind_Word (*ptr__Unwind_GetCFA)(_Unwind_Context *);
  _Unwind_Ptr (*ptr__Unwind_GetIP)(_Unwind_Context *);
  void (*ptr__Unwind_Resume)(_Unwind_Exception *);
  _Unwind_Reason_Code (*ptr_personality)(int, _Unwind_Action, _Unwind_Exception_Class, _Unwind_Exception *, _Unwind_Context *);
};

/* 627 */
struct parser_convert_state
{
  parser *parser;
  char *short_end;
  option *long_end;
  void **child_inputs_end;
};

/* 632 */
enum __ord : __int32
{
  __ord::REQUIRE_ORDER = 0x0,
  __ord::PERMUTE = 0x1,
  __ord::RETURN_IN_ORDER = 0x2,
};

/* 629 */
struct __attribute__((aligned(8))) _getopt_data
{
  int optind;
  int opterr;
  int optopt;
  char *optarg;
  int __initialized;
  char *__nextchar;
  __ord __ordering;
  int __first_nonopt;
  int __last_nonopt;
};

/* 630 */
struct parser
{
  const argp *argp;
  char *short_opts;
  option *long_opts;
  _getopt_data opt_data;
  group *groups;
  group *egroup;
  void **child_inputs;
  int try_getopt;
  argp_state state;
  void *storage;
};

/* 631 */
struct __attribute__((aligned(8))) option
{
  const char *name;
  int has_arg;
  int *flag;
  int val;
};

/* 628 */
struct parser_sizes
{
  size_t short_len;
  size_t long_len;
  size_t num_groups;
  size_t num_child_inputs;
};

/* 633 */
typedef argp_fmtstream *argp_fmtstream_t;

/* 641 */
struct argp_fmtstream
{
  FILE *stream;
  size_t lmargin;
  size_t rmargin;
  ssize_t wmargin;
  size_t point_offs;
  ssize_t point_col;
  char *buf;
  char *p;
  char *end;
};

/* 634 */
struct pentry_state
{
  const hol_entry *entry;
  argp_fmtstream_t stream;
  hol_help_state *hhstate;
  int first;
  const argp_state *state;
};

/* 638 */
struct hol_entry
{
  const argp_option *opt;
  unsigned int num;
  char *short_options;
  int group;
  hol_cluster *cluster;
  const argp *argp;
};

/* 637 */
struct hol_help_state
{
  hol_entry *prev_entry;
  int sep_groups;
  int suppressed_dup_arg;
};

/* 639 */
struct hol_cluster
{
  const char *header;
  int index;
  int group;
  hol_cluster *parent;
  const argp *argp;
  int depth;
  hol_cluster *next;
};

/* 635 */
struct hol
{
  hol_entry *entries;
  unsigned int num_entries;
  char *short_options;
  hol_cluster *clusters;
};

/* 636 */
typedef _IO_FILE __FILE;

/* 640 */
struct uparam_name
{
  const char name[14];
  bool is_bool;
  uint8_t uparams_offs;
};

/* 643 */
typedef const __int32_t *wctrans_t;

/* 644 */
typedef unsigned __int64 wctype_t;

/* 645 */
struct prof
{
  void *pr_base;
  size_t pr_size;
  size_t pr_off;
  unsigned __int64 pr_scale;
};

/* 646 */
struct itimerval
{
  timeval it_interval;
  timeval it_value;
};

/* 647 */
enum __itimer_which : __int32
{
  __itimer_which::ITIMER_REAL = 0x0,
  __itimer_which::ITIMER_VIRTUAL = 0x1,
  __itimer_which::ITIMER_PROF = 0x2,
};

/* 648 */
struct region
{
  size_t offset;
  size_t nsamples;
  unsigned int scale;
  union
  {
    void *vp;
    unsigned __int16 *us;
    unsigned int *ui;
  } sample;
  size_t start;
  size_t end;
};

/* 657 */
typedef __int64 greg_t;

/* 654 */
typedef greg_t gregset_t[23];

/* 653 */
typedef _libc_fpstate *fpregset_t;

/* 651 */
struct mcontext_t
{
  gregset_t gregs;
  fpregset_t fpregs;
  unsigned __int64 __reserved1[8];
};

/* 656 */
struct _libc_fpxreg
{
  unsigned __int16 significand[4];
  unsigned __int16 exponent;
  unsigned __int16 __glibc_reserved1[3];
};

/* 655 */
struct _libc_xmmreg
{
  __uint32_t element[4];
};

/* 650 */
struct _libc_fpstate
{
  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  _libc_fpxreg _st[8];
  _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

/* 649 */
struct ucontext_t
{
  unsigned __int64 uc_flags;
  ucontext_t *uc_link;
  stack_t uc_stack;
  mcontext_t uc_mcontext;
  sigset_t uc_sigmask;
  _libc_fpstate __fpregs_mem;
  unsigned __int64 __ssp[4];
};

/* 652 */
struct stack_t
{
  void *ss_sp;
  int ss_flags;
  size_t ss_size;
};

/* 658 */
struct gmonparam
{
  __int64 state;
  unsigned __int16 *kcount;
  unsigned __int64 kcountsize;
  unsigned __int64 *froms;
  unsigned __int64 fromssize;
  tostruct *tos;
  unsigned __int64 tossize;
  __int64 tolimit;
  unsigned __int64 lowpc;
  unsigned __int64 highpc;
  unsigned __int64 textsize;
  unsigned __int64 hashfraction;
  __int64 log_hashfraction;
};

/* 659 */
struct tostruct
{
  unsigned __int64 selfpc;
  __int64 count;
  unsigned __int64 link;
};

/* 660 */
struct gmon_cg_arc_record
{
  char from_pc[8];
  char self_pc[8];
  char count[4];
};

/* 661 */
struct __bb
{
  __int64 zero_word;
  const char *filename;
  __int64 *counts;
  __int64 ncounts;
  __bb *next;
  const unsigned __int64 *addresses;
};

/* 662 */
typedef shmid_ds shmctl_arg_t;

/* 667 */
typedef int __key_t;

/* 664 */
typedef unsigned __int64 __syscall_ulong_t;

/* 666 */
struct ipc_perm
{
  __key_t __key;
  __uid_t uid;
  __gid_t gid;
  __uid_t cuid;
  __gid_t cgid;
  __mode_t mode;
  unsigned __int16 __seq;
  unsigned __int16 __pad2;
  __syscall_ulong_t __glibc_reserved1;
  __syscall_ulong_t __glibc_reserved2;
};

/* 665 */
typedef __syscall_ulong_t shmatt_t;

/* 663 */
struct shmid_ds
{
  ipc_perm shm_perm;
  size_t shm_segsz;
  __time_t shm_atime;
  __time_t shm_dtime;
  __time_t shm_ctime;
  __pid_t shm_cpid;
  __pid_t shm_lpid;
  shmatt_t shm_nattch;
  __syscall_ulong_t __glibc_reserved5;
  __syscall_ulong_t __glibc_reserved6;
};

/* 668 */
typedef __key_t key_t;

/* 669 */
struct sembuf
{
  unsigned __int16 sem_num;
  __int16 sem_op;
  __int16 sem_flg;
};

/* 670 */
typedef semun semctl_arg_t;

/* 1049 */
union semun
{
  int val;
  semid_ds *buf;
  unsigned __int16 *array;
  seminfo *__buf;
};

/* 672 */
struct semid_ds
{
  ipc_perm sem_perm;
  __time_t sem_otime;
  __syscall_ulong_t __sem_otime_high;
  __time_t sem_ctime;
  __syscall_ulong_t __sem_ctime_high;
  __syscall_ulong_t sem_nsems;
  __syscall_ulong_t __glibc_reserved3;
  __syscall_ulong_t __glibc_reserved4;
};

/* 671 */
struct seminfo
{
  int semmap;
  int semmni;
  int semmns;
  int semmnu;
  int semmsl;
  int semopm;
  int semume;
  int semusz;
  int semvmx;
  int semaem;
};

/* 673 */
typedef msqid_ds msgctl_arg_t;

/* 676 */
typedef __syscall_ulong_t msgqnum_t;

/* 675 */
typedef __syscall_ulong_t msglen_t;

/* 674 */
struct msqid_ds
{
  ipc_perm msg_perm;
  __time_t msg_stime;
  __time_t msg_rtime;
  __time_t msg_ctime;
  __syscall_ulong_t __msg_cbytes;
  msgqnum_t msg_qnum;
  msglen_t msg_qbytes;
  __pid_t msg_lspid;
  __pid_t msg_lrpid;
  __syscall_ulong_t __glibc_reserved4;
  __syscall_ulong_t __glibc_reserved5;
};

/* 678 */
typedef unsigned __int64 __aligned_uint64_t;

/* 677 */
struct clone_args
{
  __aligned_uint64_t flags;
  __aligned_uint64_t pidfd;
  __aligned_uint64_t child_tid;
  __aligned_uint64_t parent_tid;
  __aligned_uint64_t exit_signal;
  __aligned_uint64_t stack;
  __aligned_uint64_t stack_size;
  __aligned_uint64_t tls;
  __aligned_uint64_t set_tid;
  __aligned_uint64_t set_tid_size;
  __aligned_uint64_t cgroup;
};

/* 679 */
typedef __mode_t mode_t;

/* 680 */
struct __attribute__((aligned(16))) timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;
  int tai;
  _BYTE gapA4[44];
};

/* 681 */
struct itimerspec
{
  timespec it_interval;
  timespec it_value;
};

/* 682 */
struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;
  unsigned __int8 f_handle[];
};

/* 1050 */
typedef __off64_t __loff_t;

/* 683 */
typedef __loff_t loff_t;

/* 1067 */
union epoll_data
{
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
};

/* 685 */
typedef epoll_data epoll_data_t;

/* 684 */
struct __attribute__((packed)) __attribute__((aligned(4))) epoll_event
{
  uint32_t events;
  epoll_data_t data;
};

/* 688 */
typedef unsigned __int64 __rlim64_t;

/* 687 */
typedef __rlim64_t rlim64_t;

/* 686 */
struct rlimit64
{
  rlim64_t rlim_cur;
  rlim64_t rlim_max;
};

/* 689 */
typedef uint64_t eventfd_t;

/* 690 */
struct fd_to_filename
{
  char buffer[26];
};

/* 691 */
struct __attribute__((aligned(8))) libc_ifunc_impl
{
  const char *name;
  void (*fn)(void);
  bool usable;
};

/* 694 */
typedef __int64 __kernel_long_t;

/* 693 */
typedef unsigned __int64 __kernel_ulong_t;

/* 692 */
struct __attribute__((aligned(8))) sysinfo
{
  __kernel_long_t uptime;
  __kernel_ulong_t loads[3];
  __kernel_ulong_t totalram;
  __kernel_ulong_t freeram;
  __kernel_ulong_t sharedram;
  __kernel_ulong_t bufferram;
  __kernel_ulong_t totalswap;
  __kernel_ulong_t freeswap;
  __u16 procs;
  __u16 pad;
  __kernel_ulong_t totalhigh;
  __kernel_ulong_t freehigh;
  __u32 mem_unit;
};

/* 695 */
struct regmatch_t
{
  regoff_t rm_so;
  regoff_t rm_eo;
};

/* 697 */
typedef re_pattern_buffer regex_t;

/* 700 */
typedef unsigned __int64 __re_long_size_t;

/* 699 */
typedef unsigned __int64 reg_syntax_t;

/* 792 */
struct __attribute__((aligned(16))) re_pattern_buffer
{
  re_dfa_t *buffer;
  __re_long_size_t allocated;
  __re_long_size_t used;
  reg_syntax_t syntax;
  char *fastmap;
  unsigned __int8 *translate;
  size_t re_nsub;
};

/* 698 */
struct __attribute__((aligned(8))) re_dfa_t
{
  re_token_t *nodes;
  size_t nodes_alloc;
  size_t nodes_len;
  Idx *nexts;
  Idx *org_indices;
  re_node_set *edests;
  re_node_set *eclosures;
  re_node_set *inveclosures;
  re_state_table_entry *state_table;
  re_dfastate_t *init_state;
  re_dfastate_t *init_state_word;
  re_dfastate_t *init_state_nl;
  re_dfastate_t *init_state_begbuf;
  bin_tree_t *str_tree;
  bin_tree_storage_t *str_tree_storage;
  re_bitset_ptr_t sb_char;
  int str_tree_storage_idx;
  re_hashval_t state_hash_mask;
  Idx init_node;
  Idx nbackref;
  bitset_word_t used_bkref_map;
  bitset_word_t completed_bkref_map;
  _BYTE gapA0[4];
  int mb_cur_max;
  bitset_t word_char;
  reg_syntax_t syntax;
  Idx *subexp_map;
  __libc_lock_t lock;
};

/* 813 */
enum re_context_type : __int32
{
  INSIDE_WORD = 0x5,
  WORD_FIRST = 0x6,
  WORD_LAST = 0x9,
  INSIDE_NOTWORD = 0xA,
  LINE_FIRST = 0x10,
  LINE_LAST = 0x20,
  BUF_FIRST = 0x40,
  BUF_LAST = 0x80,
  WORD_DELIM = 0x100,
  NOT_WORD_DELIM = 0x200,
};

/* 788 */
struct __attribute__((aligned(16))) re_token_t
{
  union
  {
    unsigned __int8 c;
    re_bitset_ptr_t sbcset;
    re_charset_t *mbcset;
    Idx idx;
    re_context_type ctx_type;
  } opr;
};

/* 797 */
struct re_node_set
{
  Idx alloc;
  Idx nelem;
  Idx *elems;
};

/* 801 */
struct re_state_table_entry
{
  Idx num;
  Idx alloc;
  re_dfastate_t **array;
};

/* 807 */
struct __attribute__((aligned(8))) re_dfastate_t
{
  re_hashval_t hash;
  re_node_set nodes;
  re_node_set non_eps_nodes;
  re_node_set inveclosure;
  re_node_set *entrance_nodes;
  re_dfastate_t **trtable;
  re_dfastate_t **word_trtable;
  _BYTE gap50[8];
};

/* 809 */
struct __attribute__((aligned(8))) bin_tree_t
{
  bin_tree_t *parent;
  bin_tree_t *left;
  bin_tree_t *right;
  bin_tree_t *first;
  bin_tree_t *next;
  __attribute__((packed)) __attribute__((aligned(1))) re_token_t token;
  Idx node_idx;
};

/* 808 */
struct bin_tree_storage_t
{
  bin_tree_storage_t *next;
  bin_tree_t data[15];
};

/* 812 */
struct re_charset_t
{
  wchar_t *mbchars;
  int32_t *coll_syms;
  int32_t *equiv_classes;
  uint32_t *range_starts;
  uint32_t *range_ends;
  wctype_t *char_classes;
  _BYTE gap30[4];
  Idx nmbchars;
  Idx ncoll_syms;
  Idx nequiv_classes;
  Idx nranges;
  Idx nchar_classes;
};

/* 701 */
struct __attribute__((aligned(8))) dirent64
{
  __ino64_t d_ino;
  __off64_t d_off;
  unsigned __int16 d_reclen;
  unsigned __int8 d_type;
  char d_name[256];
};

/* 702 */
typedef __dirstream DIR;

/* 1068 */
struct __dirstream
{
  int fd;
  __libc_lock_t lock;
  size_t allocation;
  size_t size;
  size_t offset;
  off_t filepos;
  int errcode;
  __attribute__((aligned(8))) char data[];
};

/* 705 */
typedef int __daddr_t;

/* 703 */
struct __attribute__((aligned(8))) ustat
{
  __daddr_t f_tfree;
  __ino_t f_tinode;
  char f_fname[6];
  char f_fpack[6];
};

/* 706 */
typedef void (*__free_fn_t)(void *);

/* 707 */
typedef node_t *node;

/* 710 */
struct node_t
{
  const void *key;
  uintptr_t left_node;
  uintptr_t right_node;
};

/* 709 */
enum VISIT : __int32
{
  preorder = 0x0,
  postorder = 0x1,
  endorder = 0x2,
  leaf = 0x3,
};

/* 708 */
typedef void (*__action_fn_t)(const void *, VISIT, int);

/* 711 */
struct hsearch_data
{
  _ENTRY *table;
  unsigned int size;
  unsigned int filled;
};

/* 715 */
struct entry
{
  char *key;
  void *data;
};

/* 712 */
typedef entry ENTRY;

/* 714 */
struct _ENTRY
{
  unsigned int used;
  ENTRY entry;
};

/* 713 */
enum ACTION : __int32
{
  FIND = 0x0,
  ENTER = 0x1,
};

/* 716 */
struct cleanup_arg
{
  void *buf;
  sigaction *oldaction;
};

/* 717 */
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  __int64 tm_gmtoff;
  const char *tm_zone;
};

/* 718 */
struct ttyent
{
  char *ty_name;
  char *ty_getty;
  char *ty_type;
  int ty_status;
  char *ty_window;
  char *ty_comment;
};

/* 719 */
struct __attribute__((aligned(8))) qelem
{
  qelem *q_forw;
  qelem *q_back;
  char q_data[1];
};

/* 720 */
struct mntent
{
  char *mnt_fsname;
  char *mnt_dir;
  char *mnt_type;
  char *mnt_opts;
  int mnt_freq;
  int mnt_passno;
};

/* 721 */
struct mntent_buffer
{
  mntent m;
  char buffer[4096];
};

/* 723 */
struct fstab
{
  char *fs_spec;
  char *fs_file;
  char *fs_vfstype;
  char *fs_mntops;
  const char *fs_type;
  int fs_freq;
  int fs_passno;
};

/* 722 */
struct fstab_state
{
  FILE *fs_fp;
  char *fs_buffer;
  mntent fs_mntres;
  fstab fs_ret;
};

/* 724 */
enum __ptrace_request : __int32
{
  __ptrace_request::PTRACE_TRACEME = 0x0,
  __ptrace_request::PTRACE_PEEKTEXT = 0x1,
  __ptrace_request::PTRACE_PEEKDATA = 0x2,
  __ptrace_request::PTRACE_PEEKUSER = 0x3,
  __ptrace_request::PTRACE_POKETEXT = 0x4,
  __ptrace_request::PTRACE_POKEDATA = 0x5,
  __ptrace_request::PTRACE_POKEUSER = 0x6,
  __ptrace_request::PTRACE_CONT = 0x7,
  __ptrace_request::PTRACE_KILL = 0x8,
  __ptrace_request::PTRACE_SINGLESTEP = 0x9,
  __ptrace_request::PTRACE_GETREGS = 0xC,
  __ptrace_request::PTRACE_SETREGS = 0xD,
  __ptrace_request::PTRACE_GETFPREGS = 0xE,
  __ptrace_request::PTRACE_SETFPREGS = 0xF,
  __ptrace_request::PTRACE_ATTACH = 0x10,
  __ptrace_request::PTRACE_DETACH = 0x11,
  __ptrace_request::PTRACE_GETFPXREGS = 0x12,
  __ptrace_request::PTRACE_SETFPXREGS = 0x13,
  __ptrace_request::PTRACE_SYSCALL = 0x18,
  __ptrace_request::PTRACE_GET_THREAD_AREA = 0x19,
  __ptrace_request::PTRACE_SET_THREAD_AREA = 0x1A,
  __ptrace_request::PTRACE_ARCH_PRCTL = 0x1E,
  __ptrace_request::PTRACE_SYSEMU = 0x1F,
  __ptrace_request::PTRACE_SYSEMU_SINGLESTEP = 0x20,
  __ptrace_request::PTRACE_SINGLEBLOCK = 0x21,
  __ptrace_request::PTRACE_SETOPTIONS = 0x4200,
  __ptrace_request::PTRACE_GETEVENTMSG = 0x4201,
  __ptrace_request::PTRACE_GETSIGINFO = 0x4202,
  __ptrace_request::PTRACE_SETSIGINFO = 0x4203,
  __ptrace_request::PTRACE_GETREGSET = 0x4204,
  __ptrace_request::PTRACE_SETREGSET = 0x4205,
  __ptrace_request::PTRACE_SEIZE = 0x4206,
  __ptrace_request::PTRACE_INTERRUPT = 0x4207,
  __ptrace_request::PTRACE_LISTEN = 0x4208,
  __ptrace_request::PTRACE_PEEKSIGINFO = 0x4209,
  __ptrace_request::PTRACE_GETSIGMASK = 0x420A,
  __ptrace_request::PTRACE_SETSIGMASK = 0x420B,
  __ptrace_request::PTRACE_SECCOMP_GET_FILTER = 0x420C,
  __ptrace_request::PTRACE_SECCOMP_GET_METADATA = 0x420D,
  __ptrace_request::PTRACE_GET_SYSCALL_INFO = 0x420E,
  __ptrace_request::PTRACE_GET_RSEQ_CONFIGURATION = 0x420F,
};

/* 725 */
struct sgttyb;

/* 727 */
typedef unsigned int __useconds_t;

/* 726 */
typedef __useconds_t useconds_t;

/* 728 */
struct xid_command
{
  int syscall_no;
  unsigned __int64 id[3];
  volatile int cntr;
  volatile int error;
};

/* 729 */
typedef __int64 intptr_t;

/* 733 */
typedef unsigned int __id_t;

/* 730 */
typedef __id_t id_t;

/* 732 */
enum __priority_which : __int32
{
  __priority_which::PRIO_PROCESS = 0x0,
  __priority_which::PRIO_PGRP = 0x1,
  __priority_which::PRIO_USER = 0x2,
};

/* 731 */
typedef __priority_which __priority_which_t;

/* 734 */
enum __rusage_who : __int32
{
  __rusage_who::RUSAGE_SELF = 0x0,
  __rusage_who::RUSAGE_CHILDREN = 0xFFFFFFFF,
  __rusage_who::RUSAGE_THREAD = 0x1,
};

/* 735 */
struct vtimes
{
  int vm_utime;
  int vm_stime;
  unsigned int vm_idsrss;
  unsigned int vm_ixrss;
  int vm_maxrss;
  int vm_majflt;
  int vm_minflt;
  int vm_nswap;
  int vm_inblk;
  int vm_oublk;
};

/* 736 */
enum __vlimit_resource : __int32
{
  __vlimit_resource::LIM_NORAISE = 0x0,
  __vlimit_resource::LIM_CPU = 0x1,
  __vlimit_resource::LIM_FSIZE = 0x2,
  __vlimit_resource::LIM_DATA = 0x3,
  __vlimit_resource::LIM_STACK = 0x4,
  __vlimit_resource::LIM_CORE = 0x5,
  __vlimit_resource::LIM_MAXRSS = 0x6,
};

/* 737 */
struct speed_struct
{
  speed_t value;
  speed_t internal;
};

/* 738 */
enum __pid_type : __int32
{
  __pid_type::F_OWNER_TID = 0x0,
  __pid_type::F_OWNER_PID = 0x1,
  __pid_type::F_OWNER_PGRP = 0x2,
  __pid_type::F_OWNER_GID = 0x2,
};

/* 741 */
typedef unsigned __int64 __fsblkcnt64_t;

/* 740 */
typedef unsigned __int64 __fsfilcnt64_t;

/* 739 */
struct statvfs64
{
  unsigned __int64 f_bsize;
  unsigned __int64 f_frsize;
  __fsblkcnt64_t f_blocks;
  __fsblkcnt64_t f_bfree;
  __fsblkcnt64_t f_bavail;
  __fsfilcnt64_t f_files;
  __fsfilcnt64_t f_ffree;
  __fsfilcnt64_t f_favail;
  unsigned __int64 f_fsid;
  unsigned __int64 f_flag;
  unsigned __int64 f_namemax;
  int __f_spare[6];
};

/* 743 */
typedef __int64 __fsword_t;

/* 744 */
struct __fsid_t
{
  int __val[2];
};

/* 742 */
struct statfs64
{
  __fsword_t f_type;
  __fsword_t f_bsize;
  __fsblkcnt64_t f_blocks;
  __fsblkcnt64_t f_bfree;
  __fsblkcnt64_t f_bavail;
  __fsfilcnt64_t f_files;
  __fsfilcnt64_t f_ffree;
  __fsid_t f_fsid;
  __fsword_t f_namelen;
  __fsword_t f_frsize;
  __fsword_t f_flags;
  __fsword_t f_spare[4];
};

/* 745 */
typedef _ftsent FTSENT;

/* 750 */
typedef __ino_t ino_t;

/* 749 */
typedef __nlink_t nlink_t;

/* 748 */
struct __attribute__((aligned(8))) _ftsent
{
  _ftsent *fts_cycle;
  _ftsent *fts_parent;
  _ftsent *fts_link;
  __int64 fts_number;
  void *fts_pointer;
  char *fts_accpath;
  char *fts_path;
  int fts_errno;
  int fts_symfd;
  unsigned __int16 fts_pathlen;
  unsigned __int16 fts_namelen;
  ino_t fts_ino;
  dev_t fts_dev;
  nlink_t fts_nlink;
  __int16 fts_level;
  unsigned __int16 fts_info;
  unsigned __int16 fts_flags;
  unsigned __int16 fts_instr;
  stat *fts_statp;
  char fts_name[1];
};

/* 746 */
struct __attribute__((aligned(8))) FTS
{
  _ftsent *fts_cur;
  _ftsent *fts_child;
  _ftsent **fts_array;
  dev_t fts_dev;
  char *fts_path;
  int fts_rfd;
  int fts_pathlen;
  int fts_nitems;
  int (*fts_compar)(const void *, const void *);
  int fts_options;
};

/* 747 */
struct __attribute__((aligned(8))) dirent
{
  __ino_t d_ino;
  __off_t d_off;
  unsigned __int16 d_reclen;
  unsigned __int8 d_type;
  char d_name[256];
};

/* 752 */
struct known_object
{
  dev_t dev;
  ino_t ino;
};

/* 757 */
struct FTW
{
  int base;
  int level;
};

/* 755 */
typedef int (*__nftw_func_t)(const char *, const stat *, int, FTW *);

/* 753 */
struct ftw_data
{
  dir_data **dirstreams;
  size_t actdir;
  size_t maxdir;
  char *dirbuf;
  size_t dirbufsize;
  FTW ftw;
  int flags;
  const int *cvt_arr;
  __nftw_func_t func;
  dev_t dev;
  void *known_objects;
};

/* 756 */
struct dir_data
{
  DIR *stream;
  int streamfd;
  char *content;
};

/* 754 */
typedef int (*__ftw_func_t)(const char *, const stat *, int);

/* 759 */
struct statx_timestamp
{
  __int64_t tv_sec;
  __uint32_t tv_nsec;
  __int32_t __statx_timestamp_pad1[1];
};

/* 758 */
struct statx
{
  __uint32_t stx_mask;
  __uint32_t stx_blksize;
  __uint64_t stx_attributes;
  __uint32_t stx_nlink;
  __uint32_t stx_uid;
  __uint32_t stx_gid;
  __uint16_t stx_mode;
  __uint16_t __statx_pad1[1];
  __uint64_t stx_ino;
  __uint64_t stx_size;
  __uint64_t stx_blocks;
  __uint64_t stx_attributes_mask;
  statx_timestamp stx_atime;
  statx_timestamp stx_btime;
  statx_timestamp stx_ctime;
  statx_timestamp stx_mtime;
  __uint32_t stx_rdev_major;
  __uint32_t stx_rdev_minor;
  __uint32_t stx_dev_major;
  __uint32_t stx_dev_minor;
  __uint64_t __statx_pad2[14];
};

/* 760 */
struct utimbuf
{
  __time_t actime;
  __time_t modtime;
};

/* 761 */
struct shmdir_name
{
  char name[269];
};

/* 762 */
struct strbuf;

/* 763 */
struct posix_spawnattr_t
{
  __int16 __flags;
  pid_t __pgrp;
  sigset_t __sd;
  sigset_t __ss;
  sched_param __sp;
  int __policy;
  int __pad[16];
};

/* 764 */
struct posix_spawn_args
{
  sigset_t oldmask;
  const char *file;
  int (*exec)(const char *, char *const *, char *const *);
  const posix_spawn_file_actions_t *fa;
  const posix_spawnattr_t *attr;
  char *const *argv;
  ptrdiff_t argc;
  char *const *envp;
  int xflags;
  int err;
};

/* 766 */
struct posix_spawn_file_actions_t
{
  int __allocated;
  int __used;
  __spawn_action *__actions;
  int __pad[16];
};

/* 767 */
struct __spawn_action
{
  enum : __int32
  {
    spawn_do_close = 0x0,
    spawn_do_dup2 = 0x1,
    spawn_do_open = 0x2,
    spawn_do_chdir = 0x3,
    spawn_do_fchdir = 0x4,
    spawn_do_closefrom = 0x5,
    spawn_do_tcsetpgrp = 0x6,
  } tag;
  union
  {
    struct
    {
      int fd;
    } close_action;
    struct
    {
      int fd;
      int newfd;
    } dup2_action;
    struct
    {
      int fd;
      char *path;
      int oflag;
      mode_t mode;
    } open_action;
    struct
    {
      char *path;
    } chdir_action;
    struct
    {
      int fd;
    } fchdir_action;
    struct
    {
      int from;
    } closefrom_action;
    struct
    {
      int fd;
    } setpgrp_action;
  } action;
};

/* 765 */
typedef __rlimit_resource __rlimit_resource_t;

/* 768 */
struct strlist
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      char **array;
    } dynarray_header;
  } u;
  char *scratch[128];
};

/* 769 */
struct wordexp_t
{
  size_t we_wordc;
  char **we_wordv;
  size_t we_offs;
};

/* 787 */
typedef unsigned __int64 __size_t;

/* 770 */
struct glob_t
{
  __size_t gl_pathc;
  char **gl_pathv;
  __size_t gl_offs;
  int gl_flags;
  void (*gl_closedir)(void *);
  dirent *(*gl_readdir)(void *);
  void *(*gl_opendir)(const char *);
  int (*gl_lstat)(const char *, stat *);
  int (*gl_stat)(const char *, stat *);
};

/* 771 */
union msgstr_t
{
  struct
  {
    char str1[42];
    char str2[37];
    char str3[23];
    char str4[43];
    char str5[24];
    char str6[26];
    char str7[36];
    char str8[26];
    char str9[39];
    char str10[26];
    char str11[13];
    char str12[31];
    char str13[17];
    char str14[21];
    char str15[18];
    char str16[24];
    char str17[39];
  };
  char str[];
};

/* 772 */
struct __attribute__((aligned(4))) gaih_servtuple
{
  int socktype;
  int protocol;
  int port;
  bool set;
};

/* 773 */
struct __attribute__((aligned(8))) gaih_result
{
  gaih_addrtuple *at;
  char *canon;
  char *h_name;
  bool free_at;
  bool got_ipv6;
};

/* 774 */
struct __attribute__((aligned(8))) sort_result_combo
{
  sort_result *results;
  int nresults;
};

/* 781 */
struct sort_result
{
  addrinfo *dest_addr;
  sockaddr_in6 source_addr;
  uint8_t source_addr_len;
  bool got_source_addr;
  uint8_t source_addr_flags;
  uint8_t prefixlen;
  uint32_t index;
  int32_t native;
};

/* 775 */
struct scopeentry
{
  union
  {
    char addr[4];
    uint32_t addr32;
  };
  uint32_t netmask;
  int32_t scope;
};

/* 776 */
struct prefixentry
{
  in6_addr prefix;
  unsigned int bits;
  int val;
};

/* 777 */
struct __attribute__((aligned(8))) gaih_service
{
  const char *name;
  int num;
};

/* 778 */
typedef int (*__compar_d_fn_t)(const void *, const void *, void *);

/* 779 */
struct scopelist
{
  scopeentry entry;
  scopelist *next;
};

/* 780 */
struct prefixlist
{
  prefixentry entry;
  prefixlist *next;
};

/* 782 */
struct __attribute__((aligned(4))) gaih_typeproto
{
  int socktype;
  int protocol;
  uint8_t protoflag;
  bool defaultflag;
  char name[8];
};

/* 786 */
typedef unsigned __int64 uint_fast32_t;

/* 785 */
typedef uint_fast32_t dirent_type;

/* 783 */
struct readdir_result
{
  const char *name;
  dirent_type type;
};

/* 784 */
struct glob_in_dir::globnames
{
  glob_in_dir::globnames *next;
  size_t count;
  char *name[];
};

/* 800 */
enum bracket_elem_type : __int32
{
  SB_CHAR = 0x0,
  MB_CHAR = 0x1,
  EQUIV_CLASS = 0x2,
  COLL_SYM = 0x3,
  CHAR_CLASS = 0x4,
};

/* 789 */
struct bracket_elem_t
{
  bracket_elem_type type;
  union
  {
    unsigned __int8 ch;
    unsigned __int8 *name;
    wchar_t wch;
  } opr;
};

/* 790 */
enum re_token_type_t : __int32
{
  NON_TYPE = 0x0,
  CHARACTER = 0x1,
  END_OF_RE = 0x2,
  SIMPLE_BRACKET = 0x3,
  OP_BACK_REF = 0x4,
  OP_PERIOD = 0x5,
  COMPLEX_BRACKET = 0x6,
  OP_UTF8_PERIOD = 0x7,
  OP_OPEN_SUBEXP = 0x8,
  OP_CLOSE_SUBEXP = 0x9,
  OP_ALT = 0xA,
  OP_DUP_ASTERISK = 0xB,
  ANCHOR = 0xC,
  CONCAT = 0x10,
  SUBEXP = 0x11,
  OP_DUP_PLUS = 0x12,
  OP_DUP_QUESTION = 0x13,
  OP_OPEN_BRACKET = 0x14,
  OP_CLOSE_BRACKET = 0x15,
  OP_CHARSET_RANGE = 0x16,
  OP_OPEN_DUP_NUM = 0x17,
  OP_CLOSE_DUP_NUM = 0x18,
  OP_NON_MATCH_LIST = 0x19,
  OP_OPEN_COLL_ELEM = 0x1A,
  OP_CLOSE_COLL_ELEM = 0x1B,
  OP_OPEN_EQUIV_CLASS = 0x1C,
  OP_CLOSE_EQUIV_CLASS = 0x1D,
  OP_OPEN_CHAR_CLASS = 0x1E,
  OP_CLOSE_CHAR_CLASS = 0x1F,
  OP_WORD = 0x20,
  OP_NOTWORD = 0x21,
  OP_SPACE = 0x22,
  OP_NOTSPACE = 0x23,
  BACK_SLASH = 0x24,
};

/* 791 */
struct re_registers
{
  __re_size_t num_regs;
  regoff_t *start;
  regoff_t *end;
};

/* 794 */
struct regmatch_list
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      regmatch_t *array;
    } dynarray_header;
  } u;
  regmatch_t scratch[16];
};

/* 795 */
struct re_fail_stack_t
{
  Idx num;
  Idx alloc;
  re_fail_stack_ent_t *stack;
};

/* 802 */
struct re_fail_stack_ent_t
{
  Idx idx;
  Idx node;
  regmatch_t *regs;
  re_node_set eps_via_nodes;
};

/* 796 */
enum reg_errcode_t : __int32
{
  _REG_ENOSYS = 0xFFFFFFFF,
  _REG_NOERROR = 0x0,
  _REG_NOMATCH = 0x1,
  _REG_BADPAT = 0x2,
  _REG_ECOLLATE = 0x3,
  _REG_ECTYPE = 0x4,
  _REG_EESCAPE = 0x5,
  _REG_ESUBREG = 0x6,
  _REG_EBRACK = 0x7,
  _REG_EPAREN = 0x8,
  _REG_EBRACE = 0x9,
  _REG_BADBR = 0xA,
  _REG_ERANGE = 0xB,
  _REG_ESPACE = 0xC,
  _REG_BADRPT = 0xD,
  _REG_EEND = 0xE,
  _REG_ESIZE = 0xF,
  _REG_ERPAREN = 0x10,
};

/* 811 */
typedef const bitset_word_t *re_const_bitset_ptr_t;

/* 810 */
struct __attribute__((aligned(8))) re_string_t
{
  const unsigned __int8 *raw_mbs;
  unsigned __int8 *mbs;
  wint_t *wcs;
  Idx *offsets;
  mbstate_t cur_state;
  Idx raw_mbs_idx;
  Idx valid_len;
  Idx valid_raw_len;
  Idx bufs_len;
  Idx cur_idx;
  Idx raw_len;
  Idx len;
  Idx raw_stop;
  Idx stop;
  unsigned int tip_context;
  unsigned __int8 *trans;
  re_const_bitset_ptr_t word_char;
  unsigned __int8 icase;
  unsigned __int8 is_utf8;
  unsigned __int8 map_notascii;
  unsigned __int8 mbs_allocated;
  unsigned __int8 offsets_needed;
  unsigned __int8 newline_anchor;
  unsigned __int8 word_ops_used;
  int mb_cur_max;
};

/* 798 */
struct re_match_context_t
{
  re_string_t input;
  const re_dfa_t *const dfa;
  int eflags;
  Idx match_last;
  Idx last_node;
  re_dfastate_t **state_log;
  Idx state_log_top;
  Idx nbkref_ents;
  Idx abkref_ents;
  re_backref_cache_entry *bkref_ents;
  int max_mb_elem_len;
  Idx nsub_tops;
  Idx asub_tops;
  re_sub_match_top_t **sub_tops;
};

/* 804 */
struct __attribute__((aligned(8))) re_backref_cache_entry
{
  Idx node;
  Idx str_idx;
  Idx subexp_from;
  Idx subexp_to;
  bitset_word_t eps_reachable_subexps_map;
  char more;
};

/* 803 */
struct re_sub_match_top_t
{
  Idx str_idx;
  Idx node;
  state_array_t *path;
  Idx alasts;
  Idx nlasts;
  re_sub_match_last_t **lasts;
};

/* 806 */
struct state_array_t
{
  Idx next_idx;
  Idx alloc;
  re_dfastate_t **array;
};

/* 805 */
struct re_sub_match_last_t
{
  Idx node;
  Idx str_idx;
  state_array_t path;
};

/* 799 */
struct re_sift_context_t
{
  re_dfastate_t **sifted_states;
  re_dfastate_t **limited_states;
  Idx last_node;
  Idx last_str_idx;
  re_node_set limits;
};

/* 814 */
struct __attribute__((aligned(8))) fnmatch_struct
{
  const char *pattern;
  const char *string;
  bool no_leading_period;
};

/* 815 */
struct wpattern_list
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      char **array;
    } dynarray_header;
  } u;
  char *scratch[8];
};

/* 816 */
struct __attribute__((aligned(8))) STRUCT
{
  const wchar_t *pattern;
  const wchar_t *string;
  bool no_leading_period;
};

/* 817 */
struct pattern_list
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      wchar_t **array;
    } dynarray_header;
  } u;
  wchar_t *scratch[8];
};

/* 820 */
typedef unsigned __int64 __fsblkcnt_t;

/* 819 */
typedef unsigned __int64 __fsfilcnt_t;

/* 818 */
struct statfs
{
  __fsword_t f_type;
  __fsword_t f_bsize;
  __fsblkcnt_t f_blocks;
  __fsblkcnt_t f_bfree;
  __fsblkcnt_t f_bavail;
  __fsfilcnt_t f_files;
  __fsfilcnt_t f_ffree;
  __fsid_t f_fsid;
  __fsword_t f_namelen;
  __fsword_t f_frsize;
  __fsword_t f_flags;
  __fsword_t f_spare[4];
};

/* 823 */
struct fork_handler
{
  void (*prepare_handler)(void);
  void (*parent_handler)(void);
  void (*child_handler)(void);
  void *dso_handle;
};

/* 821 */
struct fork_handler_list
{
  union
  {
    dynarray_header dynarray_abstract;
    struct
    {
      size_t used;
      size_t allocated;
      fork_handler *array;
    } dynarray_header;
  } u;
  fork_handler scratch[48];
};

/* 822 */
enum __run_fork_handler_type : __int32
{
  __run_fork_handler_type::atfork_run_prepare = 0x0,
  __run_fork_handler_type::atfork_run_child = 0x1,
  __run_fork_handler_type::atfork_run_parent = 0x2,
};

/* 824 */
typedef FILE *_IO_ITER;

/* 825 */
enum idtype_t : __int32
{
  P_ALL = 0x0,
  P_PID = 0x1,
  P_PGID = 0x2,
};

/* 827 */
typedef __clock_t clock_t;

/* 826 */
struct tms
{
  clock_t tms_utime;
  clock_t tms_stime;
  clock_t tms_cutime;
  clock_t tms_cstime;
};

/* 828 */
struct scandir_cancel_struct
{
  DIR *dp;
  void *v;
  size_t cnt;
};

/* 829 */
struct ntptimeval
{
  timeval time;
  __int64 maxerror;
  __int64 esterror;
  __int64 tai;
  __int64 __glibc_reserved1;
  __int64 __glibc_reserved2;
  __int64 __glibc_reserved3;
  __int64 __glibc_reserved4;
};

/* 831 */
struct __attribute__((aligned(8))) __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;
  int __cur_writer;
  int __shared;
  char __rwelision;
  unsigned __int8 __pad1[7];
  unsigned __int64 __pad2;
  unsigned int __flags;
};

/* 830 */
union pthread_rwlock_t
{
  __pthread_rwlock_arch_t __data;
  char __size[56];
  __int64 __align;
};

/* 832 */
struct __attribute__((aligned(4))) timeb
{
  time_t time;
  unsigned __int16 millitm;
  __int16 timezone;
  __int16 dstflag;
};

/* 833 */
typedef __int64 mktime_offset_t;

/* 834 */
typedef __itimer_which __itimer_which_t;

/* 835 */
struct leap
{
  time_t transition;
  __int64 change;
};

/* 836 */
struct ttinfo
{
  int offset;
  unsigned __int8 isdst;
  unsigned __int8 idx;
  unsigned __int8 isstd;
  unsigned __int8 isgmt;
};

/* 837 */
struct __attribute__((aligned(8))) tz_rule
{
  const char *name;
  enum : __int32
  {
    J0 = 0x0,
    J1 = 0x1,
    M = 0x2,
  } type;
  unsigned __int16 m;
  unsigned __int16 n;
  unsigned __int16 d;
  int secs;
  int offset;
  time_t change;
  int computed_for;
};

/* 838 */
struct tzstring_l
{
  tzstring_l *next;
  size_t len;
  char data[];
};

/* 839 */
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};

/* 840 */
typedef __int64 long_int;

/* 841 */
typedef unsigned __int64 mp_limb_t;

/* 842 */
typedef __int64 mp_size_t;

/* 843 */
typedef const mp_limb_t *mp_srcptr;

/* 844 */
typedef mp_limb_t *mp_ptr;

/* 847 */
typedef __int64 __intmax_t;

/* 845 */
typedef __intmax_t intmax_t;

/* 846 */
struct mp_power
{
  size_t arrayoff;
  mp_size_t arraysize;
  int p_expo;
  int m_expo;
};

/* 1051 */
typedef __uint32_t __uint_least32_t;

/* 848 */
typedef __uint_least32_t char32_t;

/* 1052 */
typedef __uint16_t __uint_least16_t;

/* 849 */
typedef __uint_least16_t char16_t;

/* 850 */
typedef _IO_strfile_ _IO_strfile;

/* 852 */
struct _IO_streambuf
{
  FILE _f;
  const _IO_jump_t *vtable;
};

/* 854 */
typedef void *(*_IO_alloc_type)(size_t);

/* 853 */
typedef void (*_IO_free_type)(void *);

/* 851 */
struct _IO_str_fields
{
  _IO_alloc_type _allocate_buffer_unused;
  _IO_free_type _free_buffer_unused;
};

/* 943 */
struct _IO_strfile_
{
  _IO_streambuf _sbf;
  _IO_str_fields _s;
};

/* 855 */
struct locale_data_t
{
  uint_fast32_t nrules;
  unsigned __int8 *rulesets;
  wint_t *weights;
  int32_t *table;
  wint_t *extra;
  int32_t *indirect;
};

/* 856 */
struct coll_seq
{
  int len;
  size_t val;
  size_t idxmax;
  size_t idxcnt;
  size_t backw;
  size_t backw_stop;
  const wint_t *us;
  unsigned __int8 rule;
  int32_t idx;
  int32_t save_idx;
  const wint_t *back_us;
};

/* 857 */
typedef _0 __m128i_u;

/* 858 */
struct __STRING2_COPY_ARR8
{
  unsigned __int8 __arr[8];
};

/* 859 */
struct __STRING2_COPY_ARR7
{
  unsigned __int8 __arr[7];
};

/* 860 */
struct __STRING2_COPY_ARR6
{
  unsigned __int8 __arr[6];
};

/* 861 */
struct __STRING2_COPY_ARR5
{
  unsigned __int8 __arr[5];
};

/* 862 */
struct __STRING2_COPY_ARR4
{
  unsigned __int8 __arr[4];
};

/* 863 */
struct __STRING2_COPY_ARR3
{
  unsigned __int8 __arr[3];
};

/* 864 */
struct __STRING2_COPY_ARR2
{
  unsigned __int8 __arr[2];
};

/* 865 */
struct random_data
{
  int32_t *fptr;
  int32_t *rptr;
  int32_t *state;
  int rand_type;
  int rand_deg;
  int rand_sep;
  int32_t *end_ptr;
};

/* 866 */
struct dl_action_result
{
  int errcode;
  char errstring_source;
  bool returned;
  const char *objname;
  char *errstring;
};

/* 867 */
struct dynarray_finalize_result
{
  void *array;
  size_t length;
};

/* 869 */
enum mcheck_status : __int32
{
  mcheck_status::MCHECK_DISABLED = 0xFFFFFFFF,
  mcheck_status::MCHECK_OK = 0x0,
  mcheck_status::MCHECK_FREE = 0x1,
  mcheck_status::MCHECK_HEAD = 0x2,
  mcheck_status::MCHECK_TAIL = 0x3,
};

/* 870 */
typedef malloc_state *mstate;

/* 872 */
struct mallinfo2
{
  size_t arena;
  size_t ordblks;
  size_t smblks;
  size_t hblks;
  size_t hblkhd;
  size_t usmblks;
  size_t fsmblks;
  size_t uordblks;
  size_t fordblks;
  size_t keepcost;
};

/* 873 */
typedef _heap_info heap_info;

/* 878 */
struct _heap_info
{
  mstate ar_ptr;
  _heap_info *prev;
  size_t size;
  size_t mprotect_size;
  size_t pagesize;
  char pad[8];
};

/* 874 */
typedef void (*tunable_callback_t)(tunable_val_t *);

/* 880 */
typedef intmax_t tunable_num_t;

/* 879 */
union tunable_val_t
{
  tunable_num_t numval;
  const char *strval;
};

/* 875 */
enum tunable_id_t : __int32
{
  glibc_rtld_nns = 0x0,
  glibc_elision_skip_lock_after_retries = 0x1,
  glibc_malloc_trim_threshold = 0x2,
  glibc_malloc_perturb = 0x3,
  glibc_cpu_x86_shared_cache_size = 0x4,
  glibc_pthread_rseq = 0x5,
  glibc_mem_tagging = 0x6,
  glibc_elision_tries = 0x7,
  glibc_elision_enable = 0x8,
  glibc_malloc_hugetlb = 0x9,
  glibc_cpu_x86_rep_movsb_threshold = 0xA,
  glibc_malloc_mxfast = 0xB,
  glibc_rtld_dynamic_sort = 0xC,
  glibc_elision_skip_lock_busy = 0xD,
  glibc_malloc_top_pad = 0xE,
  glibc_cpu_x86_rep_stosb_threshold = 0xF,
  glibc_cpu_x86_non_temporal_threshold = 0x10,
  glibc_cpu_x86_shstk = 0x11,
  glibc_pthread_stack_cache_size = 0x12,
  glibc_cpu_hwcap_mask = 0x13,
  glibc_malloc_mmap_max = 0x14,
  glibc_elision_skip_trylock_internal_abort = 0x15,
  glibc_malloc_tcache_unsorted_limit = 0x16,
  glibc_cpu_x86_ibt = 0x17,
  glibc_cpu_hwcaps = 0x18,
  glibc_elision_skip_lock_internal_abort = 0x19,
  glibc_malloc_arena_max = 0x1A,
  glibc_malloc_mmap_threshold = 0x1B,
  glibc_cpu_x86_data_cache_size = 0x1C,
  glibc_malloc_tcache_count = 0x1D,
  glibc_malloc_arena_test = 0x1E,
  glibc_pthread_mutex_spin_count = 0x1F,
  glibc_rtld_optional_static_tls = 0x20,
  glibc_malloc_tcache_max = 0x21,
  glibc_malloc_check = 0x22,
};

/* 876 */
struct tcache_perthread_struct
{
  uint16_t counts[64];
  tcache_entry *entries[64];
};

/* 877 */
struct tcache_entry
{
  tcache_entry *next;
  uintptr_t key;
};

/* 881 */
struct thread_start_data
{
  void (*thrfunc)(sigval_t);
  sigval_t sival;
};

/* 882 */
struct timer
{
  kernel_timer_t ktimerid;
  void (*thrfunc)(sigval_t);
  sigval_t sival;
  pthread_attr_t attr;
  timer *next;
};

/* 884 */
typedef void *__timer_t;

/* 883 */
typedef __timer_t timer_t;

/* 885 */
typedef int mqd_t;

/* 886 */
struct mq_attr
{
  __syscall_slong_t mq_flags;
  __syscall_slong_t mq_maxmsg;
  __syscall_slong_t mq_msgsize;
  __syscall_slong_t mq_curmsgs;
  __syscall_slong_t __pad[4];
};

/* 887 */
union pthread_barrier_t
{
  char __size[32];
  __int64 __align;
};

/* 888 */
union notify_data
{
  struct
  {
    void (*fct)(sigval);
    sigval param;
    pthread_attr_t *attr;
  };
  char raw[32];
};

/* 889 */
union pthread_barrierattr_t
{
  char __size[4];
  int __align;
};

/* 892 */
struct aiocb
{
  int aio_fildes;
  int aio_lio_opcode;
  int aio_reqprio;
  volatile void *aio_buf;
  size_t aio_nbytes;
  sigevent aio_sigevent;
  aiocb *__next_prio;
  int __abs_prio;
  int __policy;
  int __error_code;
  __ssize_t __return_value;
  __off_t aio_offset;
  char __glibc_reserved[32];
};

/* 891 */
struct aiocb64
{
  int aio_fildes;
  int aio_lio_opcode;
  int aio_reqprio;
  volatile void *aio_buf;
  size_t aio_nbytes;
  sigevent aio_sigevent;
  aiocb *__next_prio;
  int __abs_prio;
  int __policy;
  int __error_code;
  __ssize_t __return_value;
  __off64_t aio_offset;
  char __glibc_reserved[32];
};

/* 890 */
union aiocb_union
{
  aiocb aiocb;
  aiocb64 aiocb64;
};

/* 893 */
struct __attribute__((aligned(8))) clparam
{
  const aiocb *const *list;
  waitlist *waitlist;
  requestlist **requestlist;
  int nent;
};

/* 894 */
struct aioinit
{
  int aio_threads;
  int aio_num;
  int aio_locks;
  int aio_usedba;
  int aio_debug;
  int aio_numusers;
  int aio_idle_time;
  int aio_reserved;
};

/* 897 */
typedef unsigned int __tss_t;

/* 895 */
typedef __tss_t tss_t;

/* 896 */
typedef unsigned int pthread_key_t;

/* 898 */
typedef void (*tss_dtor_t)(void *);

/* 900 */
typedef unsigned __int64 __thrd_t;

/* 899 */
typedef __thrd_t thrd_t;

/* 901 */
typedef int (*thrd_start_t)(void *);

/* 902 */
union mtx_t
{
  char __size[40];
  __int64 __align;
};

/* 903 */
union pthread_mutexattr_t
{
  char __size[4];
  int __align;
};

/* 904 */
union cnd_t
{
  char __size[48];
  __int64 __align;
};

/* 905 */
union pthread_condattr_t
{
  char __size[4];
  int __align;
};

/* 906 */
typedef __once_flag once_flag;

/* 1053 */
struct __once_flag
{
  int __data;
};

/* 908 */
struct __attribute__((aligned(8))) __cancel_jmp_buf_tag
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

/* 907 */
struct __pthread_unwind_buf_t
{
  __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
};

/* 909 */
struct new_sem
{
  uint64_t data;
  int private;
  int pad;
};

/* 910 */
union sem_t
{
  char __size[32];
  __int64 __align;
};

/* 911 */
struct walk_closure
{
  sem_t *the_sem;
  inuse_sem *rec;
};

/* 912 */
struct inuse_sem
{
  dev_t dev;
  ino_t ino;
  int refcnt;
  sem_t *sem;
  char name[];
};

/* 913 */
typedef volatile int pthread_spinlock_t;

/* 914 */
struct pthread_key_struct
{
  uintptr_t seq;
  void (*destr)(void *);
};

/* 915 */
struct pthread_rwlockattr
{
  int lockkind;
  int pshared;
};

/* 916 */
union pthread_rwlockattr_t
{
  char __size[8];
  __int64 __align;
};

/* 917 */
struct __pthread_cleanup_combined_frame
{
  void (*__cancel_routine)(void *);
  void *__cancel_arg;
  int __do_it;
  _pthread_cleanup_buffer __buffer;
};

/* 918 */
struct pthread_mutexattr
{
  int mutexkind;
};

/* 919 */
struct __attribute__((aligned(8))) rtld_global
{
  link_namespaces _dl_ns[16];
  size_t _dl_nns;
  __rtld_lock_recursive_t _dl_load_lock;
  __rtld_lock_recursive_t _dl_load_write_lock;
  __rtld_lock_recursive_t _dl_load_tls_lock;
  unsigned __int64 _dl_load_adds;
  link_map *_dl_initfirst;
  link_map *_dl_profile_map;
  unsigned __int64 _dl_num_relocations;
  unsigned __int64 _dl_num_cache_relocations;
  r_search_path_elem *_dl_all_dirs;
  link_map _dl_rtld_map;
  auditstate _dl_rtld_auditstate[16];
  unsigned int _dl_x86_feature_1;
  dl_x86_feature_control _dl_x86_feature_control;
  Elf64_Word _dl_stack_flags;
  bool _dl_tls_dtv_gaps;
  size_t _dl_tls_max_dtv_idx;
  dtv_slotinfo_list *_dl_tls_dtv_slotinfo_list;
  size_t _dl_tls_static_nelem;
  size_t _dl_tls_static_used;
  size_t _dl_tls_static_optional;
  void *_dl_initial_dtv;
  size_t _dl_tls_generation;
  dl_scope_free_list *_dl_scope_free_list;
  list_t _dl_stack_used;
  list_t _dl_stack_user;
  list_t _dl_stack_cache;
  size_t _dl_stack_cache_actsize;
  uintptr_t _dl_in_flight_stack;
  int _dl_stack_cache_lock;
};

/* 921 */
struct pthread_condattr
{
  int value;
};

/* 922 */
struct __attribute__((aligned(8))) _condvar_cleanup_buffer
{
  uint64_t wseq;
  pthread_cond_t *cond;
  pthread_mutex_t *mutex;
  int private;
};

/* 923 */
struct pthread_barrier
{
  unsigned int in;
  unsigned int current_round;
  unsigned int count;
  int shared;
  unsigned int out;
};

/* 924 */
struct pthread_barrierattr
{
  int pshared;
};

/* 925 */
struct pthread_cond_2_0_t
{
  pthread_cond_t *cond;
};

/* 926 */
struct dlvsym_args
{
  void *handle;
  const char *name;
  const char *version;
  void *who;
  void *sym;
};

/* 927 */
struct dlsym_args
{
  void *handle;
  const char *name;
  void *who;
  void *sym;
};

/* 928 */
struct dlopen_args
{
  const char *file;
  int mode;
  void *new;
  const void *caller;
};

/* 929 */
struct dlmopen_args
{
  Lmid_t nsid;
  const char *file;
  int mode;
  void *new;
  const void *caller;
};

/* 930 */
struct dlinfo_args
{
  void *handle;
  int request;
  void *arg;
};

/* 932 */
struct __attribute__((aligned(8))) Dl_serpath
{
  char *dls_name;
  unsigned int dls_flags;
};

/* 931 */
struct Dl_serinfo
{
  size_t dls_size;
  unsigned int dls_cnt;
  union
  {
    Dl_serpath dls_serpath[];
    Dl_serpath __dls_serpath_pad[1];
  };
};

/* 933 */
struct _IO_FILE_plus
{
  FILE file;
  const _IO_jump_t *vtable;
};

/* 934 */
typedef fmemopen_cookie_struct fmemopen_cookie_t;

/* 1054 */
struct fmemopen_cookie_struct
{
  char *buffer;
  int mybuffer;
  int binmode;
  size_t size;
  off64_t pos;
  size_t maxpos;
};

/* 935 */
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

/* 939 */
typedef __ssize_t cookie_read_function_t(void *, char *, size_t);

/* 938 */
typedef __ssize_t cookie_write_function_t(void *, const char *, size_t);

/* 937 */
typedef int cookie_seek_function_t(void *, __off64_t *, int);

/* 936 */
typedef int cookie_close_function_t(void *);

/* 1055 */
struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
};

/* 940 */
struct str_list
{
  const char *str;
  size_t len;
  str_list *next;
};

/* 941 */
struct abort_msg_s
{
  unsigned int size;
  char msg[];
};

/* 942 */
struct _IO_obstack_file
{
  _IO_FILE_plus file;
  obstack *obstack;
};

/* 944 */
struct _IO_strnfile
{
  _IO_strfile f;
  char overflow_buf[64];
};

/* 946 */
struct _IO_FILE_memstream
{
  _IO_strfile _sf;
  char **bufloc;
  size_t *sizeloc;
};

/* 945 */
struct __open_memstream::locked_FILE
{
  _IO_FILE_memstream fp;
  _IO_lock_t lock;
  _IO_wide_data wd;
};

/* 948 */
struct _IO_FILE_wmemstream
{
  _IO_strfile _sf;
  wchar_t **bufloc;
  size_t *sizeloc;
};

/* 947 */
struct open_wmemstream::locked_FILE
{
  _IO_FILE_wmemstream fp;
  _IO_lock_t lock;
  _IO_wide_data wd;
};

/* 949 */
struct _IO_wstrnfile
{
  _IO_strfile f;
  wchar_t overflow_buf[64];
};

/* 951 */
struct _IO_proc_file
{
  _IO_FILE_plus file;
  pid_t pid;
  _IO_proc_file *next;
};

/* 950 */
struct _IO_new_popen::locked_FILE
{
  _IO_proc_file fpx;
  _IO_lock_t lock;
};

/* 952 */
struct _IO_cookie_file
{
  _IO_FILE_plus __fp;
  void *__cookie;
  cookie_io_functions_t __io_functions;
};

/* 953 */
struct _IO_fopencookie::locked_FILE
{
  _IO_cookie_file cfile;
  _IO_lock_t lock;
};

/* 954 */
struct __fopen_internal::locked_FILE
{
  _IO_FILE_plus fp;
  _IO_lock_t lock;
  _IO_wide_data wd;
};

/* 955 */
struct _IO_new_fdopen::locked_FILE
{
  _IO_FILE_plus fp;
  _IO_lock_t lock;
  _IO_wide_data wd;
};

/* 957 */
struct printf_info
{
  int prec;
  int width;
  wchar_t spec;
  _BYTE gapC[2];
  unsigned __int16 user;
  wchar_t pad;
};

/* 956 */
struct __attribute__((aligned(8))) printf_spec
{
  printf_info info;
  const unsigned int *end_of_fmt;
  const unsigned int *next_fmt;
  int prec_arg;
  int width_arg;
  int data_arg;
  int data_arg_type;
  size_t ndata_args;
  int size;
};

/* 958 */
struct __attribute__((aligned(8))) printf_modifier_record
{
  printf_modifier_record *next;
  int bit;
};

/* 959 */
typedef int printf_function(FILE *, const printf_info *, const void *const *);

/* 960 */
typedef int printf_arginfo_size_function(const printf_info *, size_t, int *, int *);

/* 961 */
union sys_errname_t
{
  struct
  {
    char str1[2];
    char str6[6];
    char str13[7];
    char str18[6];
    char str29[6];
    char str34[4];
    char str43[6];
    char str51[6];
    char str57[8];
    char str64[6];
    char str71[7];
    char str79[8];
    char str85[7];
    char str90[7];
    char str96[7];
    char str103[8];
    char str110[6];
    char str116[7];
    char str123[6];
    char str129[7];
    char str134[8];
    char str140[7];
    char str146[7];
    char str157[7];
    char str164[7];
    char str170[7];
    char str179[8];
    char str184[6];
    char str190[7];
    char str195[7];
    char str200[6];
    char str207[7];
    char str216[6];
    char str222[5];
    char str228[7];
    char str261[7];
    char str273[12];
    char str279[9];
    char str284[9];
    char str290[9];
    char str295[11];
    char str301[12];
    char str308[16];
    char str313[16];
    char str323[11];
    char str328[13];
    char str334[13];
    char str339[11];
    char str346[14];
    char str351[9];
    char str357[12];
    char str362[10];
    char str367[13];
    char str374[11];
    char str381[8];
    char str387[8];
    char str395[9];
    char str402[13];
    char str407[10];
    char str410[13];
    char str416[10];
    char str422[13];
    char str428[6];
    char str435[13];
    char str440[10];
    char str445[13];
    char str451[10];
    char str457[7];
    char str462[7];
    char str471[7];
    char str479[8];
    char str487[7];
    char str496[7];
    char str502[7];
    char str505[8];
    char str508[6];
    char str511[10];
    char str514[8];
    char str517[8];
    char str520[7];
    char str523[6];
    char str526[7];
    char str529[10];
    char str532[7];
    char str535[6];
    char str543[10];
    char str546[11];
    char str549[16];
    char str552[9];
    char str555[7];
    char str558[9];
    char str561[7];
    char str564[7];
    char str567[7];
    char str570[8];
    char str573[7];
    char str576[7];
    char str579[6];
    char str582[6];
    char str585[7];
    char str588[7];
    char str591[8];
    char str594[8];
    char str597[7];
    char str600[7];
    char str603[7];
    char str606[5];
    char str609[7];
    char str612[6];
    char str615[8];
    char str618[9];
    char str621[7];
    char str624[8];
    char str627[8];
    char str630[8];
    char str633[8];
    char str636[8];
    char str639[9];
    char str642[9];
    char str645[8];
    char str648[8];
    char str651[8];
    char str654[7];
    char str657[10];
    char str660[10];
    char str663[12];
    char str666[7];
    char str669[12];
    char str672[12];
    char str675[13];
    char str678[8];
    char str681[10];
  };
  char str[];
};

/* 962 */
union printf_arg
{
  wchar_t pa_wchar;
  int pa_int;
  __int64 pa_long_int;
  __int64 pa_long_long_int;
  unsigned int pa_u_int;
  unsigned __int64 pa_u_long_int;
  unsigned __int64 pa_u_long_long_int;
  double pa_double;
  long double pa_long_double;
  _Float128 pa_float128;
  const char *pa_string;
  const wchar_t *pa_wstring;
  void *pa_pointer;
  void *pa_user;
};

/* 963 */
typedef wchar_t THOUSANDS_SEP_T;

/* 965 */
typedef __gnuc_va_list va_list;

/* 964 */
typedef void printf_va_arg_function(void *, va_list *);

/* 966 */
struct char_buffer
{
  wchar_t *current;
  wchar_t *end;
  scratch_buffer scratch;
};

/* 967 */
struct ptrs_to_free
{
  size_t count;
  ptrs_to_free *next;
  char **ptrs[32];
};

/* 968 */
union codestrs_t_29
{
  struct
  {
    char str_43[21];
    char str_44[25];
    char str_45[24];
    char str_46[10];
    char str_47[30];
    char str_48[20];
  };
  char str[];
};

/* 969 */
union codestrs_t_17
{
  struct
  {
    char str_35[17];
    char str_36[63];
    char str_37[56];
    char str_38[25];
    char str_39[18];
    char str_40[28];
  };
  char str[];
};

/* 970 */
union codestrs_t_5
{
  struct
  {
    char str_31[19];
    char str_32[19];
  };
  char str[];
};

/* 971 */
union codestrs_t_7
{
  struct
  {
    char str_26[26];
    char str_27[29];
    char str_28[31];
  };
  char str[];
};

/* 972 */
union codestrs_t_11
{
  struct
  {
    char str_22[29];
    char str_23[38];
  };
  char str[];
};

/* 973 */
union codestrs_t_8
{
  struct
  {
    char str_12[23];
    char str_13[17];
    char str_14[30];
    char str_15[24];
    char str_16[25];
    char str_17[30];
    char str_18[33];
    char str_19[23];
  };
  char str[];
};

/* 974 */
union codestrs_t_4
{
  struct
  {
    char str_2[15];
    char str_3[16];
    char str_4[24];
    char str_5[13];
    char str_6[18];
    char str_7[20];
    char str_8[18];
    char str_9[21];
  };
  char str[];
};

/* 976 */
typedef unsigned __int64 uint_fast64_t;

/* 975 */
typedef uint_fast64_t random_value;

/* 977 */
union ieee754_double
{
  double d;
  struct
  {
    _BYTE gap0[8];
  } ieee;
  struct
  {
    _BYTE gap0[8];
  } ieee_nan;
};

/* 978 */
typedef int printf_arginfo_function(const printf_info *, size_t, int *);

/* 979 */
struct hack_digit_param
{
  int expsign;
  int type;
  int exponent;
  mp_limb_t *frac;
  mp_size_t fracsize;
  mp_limb_t *scale;
  mp_size_t scalesize;
  mp_limb_t *tmp;
  mp_size_t tmpsize;
};

/* 980 */
struct severity_info
{
  int severity;
  const char *string;
  severity_info *next;
};

/* 981 */
typedef int nl_item;

/* 982 */
struct __attribute__((aligned(8))) cancel_handler_args
{
  sigaction *quit;
  sigaction *intr;
  pid_t pid;
};

/* 983 */
struct random_poly_info
{
  int seps[5];
  int degrees[5];
};

/* 984 */
typedef void (*dtor_func)(void *);

/* 985 */
struct dtor_list
{
  dtor_func func;
  void *obj;
  link_map *map;
  dtor_list *next;
};

/* 986 */
struct exit_function
{
  __int64 flavor;
  union
  {
    void (*at)(void);
    struct
    {
      void (*fn)(int, void *);
      void *arg;
    } on;
    struct
    {
      void (*fn)(void *, int);
      void *arg;
      void *dso_handle;
    } cxa;
  } func;
};

/* 987 */
struct exit_function_list
{
  exit_function_list *next;
  size_t idx;
  exit_function fns[32];
};

/* 988 */
struct msort_param
{
  size_t s;
  size_t var;
  __compar_d_fn_t cmp;
  void *arg;
  char *t;
};

/* 989 */
struct stack_node
{
  char *lo;
  char *hi;
};

/* 990 */
struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned __int16 cs;
  unsigned __int16 gs;
  unsigned __int16 fs;
  unsigned __int16 __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  union
  {
    _fpstate *fpstate;
    __uint64_t __fpstate_word;
  };
  __uint64_t __reserved1[8];
};

/* 993 */
struct _fpxreg
{
  unsigned __int16 significand[4];
  unsigned __int16 exponent;
  unsigned __int16 __glibc_reserved1[3];
};

/* 992 */
struct _xmmreg
{
  __uint32_t element[4];
};

/* 991 */
struct _fpstate
{
  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  _fpxreg _st[8];
  _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

/* 994 */
struct __attribute__((aligned(8))) sigstack
{
  void *ss_sp;
  int ss_onstack;
};

/* 995 */
struct sigvec
{
  __sighandler_t sv_handler;
  int sv_mask;
  int sv_flags;
};

/* 996 */
typedef catalog_info *__nl_catd;

/* 997 */
struct catalog_info
{
  enum : __int32
  {
    mmapped = 0x0,
    malloced = 0x1,
  } status;
  size_t plane_size;
  size_t plane_depth;
  uint32_t *name_ptr;
  const char *strings;
  catalog_obj *file_ptr;
  size_t file_size;
};

/* 998 */
struct catalog_obj
{
  uint32_t magic;
  uint32_t plane_size;
  uint32_t plane_depth;
  uint32_t name_ptr[];
};

/* 999 */
typedef void *nl_catd;

/* 1000 */
struct parse_args
{
  const char *cp;
  expression *res;
};

/* 1003 */
typedef char yytype_int8;

/* 1002 */
typedef yytype_int8 yy_state_t;

/* 1005 */
union YYSTYPE
{
  unsigned __int64 num;
  expression_operator op;
  expression *exp;
};

/* 1001 */
union yyalloc
{
  yy_state_t yyss_alloc;
  YYSTYPE yyvs_alloc;
};

/* 1004 */
enum yysymbol_kind_t : __int32
{
  yysymbol_kind_t::YYSYMBOL_YYEMPTY = 0xFFFFFFFE,
  yysymbol_kind_t::YYSYMBOL_YYEOF = 0x0,
  yysymbol_kind_t::YYSYMBOL_YYerror = 0x1,
  yysymbol_kind_t::YYSYMBOL_YYUNDEF = 0x2,
  yysymbol_kind_t::YYSYMBOL_3_ = 0x3,
  yysymbol_kind_t::YYSYMBOL_4_ = 0x4,
  yysymbol_kind_t::YYSYMBOL_5_ = 0x5,
  yysymbol_kind_t::YYSYMBOL_6_ = 0x6,
  yysymbol_kind_t::YYSYMBOL_EQUOP2 = 0x7,
  yysymbol_kind_t::YYSYMBOL_CMPOP2 = 0x8,
  yysymbol_kind_t::YYSYMBOL_ADDOP2 = 0x9,
  yysymbol_kind_t::YYSYMBOL_MULOP2 = 0xA,
  yysymbol_kind_t::YYSYMBOL_NUMBER = 0xB,
  yysymbol_kind_t::YYSYMBOL_12_ = 0xC,
  yysymbol_kind_t::YYSYMBOL_13_n_ = 0xD,
  yysymbol_kind_t::YYSYMBOL_14_ = 0xE,
  yysymbol_kind_t::YYSYMBOL_15_ = 0xF,
  yysymbol_kind_t::YYSYMBOL_YYACCEPT = 0x10,
  yysymbol_kind_t::YYSYMBOL_start = 0x11,
  yysymbol_kind_t::YYSYMBOL_exp = 0x12,
};

/* 1006 */
struct alias_map
{
  const char *alias;
  const char *value;
};

/* 1007 */
typedef unsigned int nls_uint32;

/* 1008 */
struct sysdep_string_desc
{
  size_t length;
  const char *pointer;
};

/* 1009 */
struct mo_file_header
{
  nls_uint32 magic;
  nls_uint32 revision;
  nls_uint32 nstrings;
  nls_uint32 orig_tab_offset;
  nls_uint32 trans_tab_offset;
  nls_uint32 hash_tab_size;
  nls_uint32 hash_tab_offset;
  nls_uint32 n_sysdep_segments;
  nls_uint32 sysdep_segments_offset;
  nls_uint32 n_sysdep_strings;
  nls_uint32 orig_sysdep_tab_offset;
  nls_uint32 trans_sysdep_tab_offset;
};

/* 1014 */
typedef pthread_rwlock_t __libc_rwlock_t;

/* 1010 */
struct loaded_domain
{
  const char *data;
  int use_mmap;
  size_t mmap_size;
  int must_swap;
  void *malloced;
  nls_uint32 nstrings;
  const string_desc *orig_tab;
  const string_desc *trans_tab;
  nls_uint32 n_sysdep_strings;
  const sysdep_string_desc *orig_sysdep_tab;
  const sysdep_string_desc *trans_sysdep_tab;
  nls_uint32 hash_size;
  const nls_uint32 *hash_tab;
  int must_swap_hash_tab;
  converted_domain *conversions;
  size_t nconversions;
  __libc_rwlock_t conversions_lock;
  const expression *plural;
  unsigned __int64 nplurals;
};

/* 1019 */
struct string_desc
{
  nls_uint32 length;
  nls_uint32 offset;
};

/* 1011 */
typedef __gconv_info *__gconv_t;

/* 1013 */
struct converted_domain
{
  const char *encoding;
  __gconv_t conv;
  char **conv_tab;
};

/* 1015 */
struct __gconv_info
{
  size_t __nsteps;
  __gconv_step *__steps;
  __gconv_step_data __data[];
};

/* 1012 */
struct binding
{
  binding *next;
  char *dirname;
  char *codeset;
  char domainname[];
};

/* 1016 */
struct segment_pair
{
  nls_uint32 segsize;
  nls_uint32 sysdepref;
};

/* 1017 */
struct sysdep_string
{
  nls_uint32 offset;
  segment_pair segments[1];
};

/* 1018 */
struct sysdep_segment
{
  nls_uint32 length;
  nls_uint32 offset;
};

/* 1020 */
struct known_translation_t
{
  const char *domainname;
  int category;
  const char *localename;
  int counter;
  loaded_l10nfile *domain;
  const char *translation;
  size_t translation_length;
  union
  {
    char appended[];
    const char *ptr;
  } msgid;
};

/* 1021 */
typedef transmem_list transmem_block_t;

/* 1023 */
struct transmem_list
{
  transmem_list *next;
  char data[];
};

/* 1022 */
struct __attribute__((aligned(8))) gconv_spec
{
  char *fromcode;
  char *tocode;
  bool translit;
  bool ignore;
};

/* 1024 */
struct catnamestr_t
{
  char str41[11];
  char str67[9];
  char str140[12];
  char str193[11];
  char str207[8];
  char str259[12];
  char str270[9];
  char str279[8];
  char str292[11];
  char str311[13];
  char str322[15];
  char str330[18];
};

/* 1025 */
struct __attribute__((aligned(4))) lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};

/* 1026 */
struct range
{
  uint32_t from;
  uint32_t len;
  int category;
  void *result;
};

/* 1027 */
struct locrecent
{
  uint32_t refs;
  struct {uint32_t offset;uint32_t len;}; record[13];
};

/* 1028 */
struct namehashent
{
  uint32_t hashval;
  uint32_t name_offset;
  uint32_t locrec_offset;
};

/* 1029 */
struct locarhead
{
  uint32_t magic;
  uint32_t serial;
  uint32_t namehash_offset;
  uint32_t namehash_used;
  uint32_t namehash_size;
  uint32_t string_offset;
  uint32_t string_used;
  uint32_t string_size;
  uint32_t locrectab_offset;
  uint32_t locrectab_used;
  uint32_t locrectab_size;
  uint32_t sumhash_offset;
  uint32_t sumhash_used;
  uint32_t sumhash_size;
};

/* 1030 */
struct locale_in_archive
{
  locale_in_archive *next;
  char *name;
  __locale_data *data[13];
};

/* 1031 */
struct archmapped
{
  void *ptr;
  uint32_t from;
  uint32_t len;
  archmapped *next;
};

/* 1032 */
enum value_type : __int32
{
  value_type::none = 0x0,
  value_type::string = 0x1,
  value_type::stringarray = 0x2,
  value_type::byte = 0x3,
  value_type::bytearray = 0x4,
  value_type::word = 0x5,
  value_type::stringlist = 0x6,
  value_type::wordarray = 0x7,
  value_type::wstring = 0x8,
  value_type::wstringarray = 0x9,
  value_type::wstringlist = 0xA,
};

/* 1033 */
struct __attribute__((aligned(8))) gconv_parsed_code
{
  char *code;
  bool translit;
  bool ignore;
};

/* 1037 */
typedef uint16_t gidx_t;

/* 1034 */
struct __attribute__((aligned(4))) gconvcache_header
{
  uint32_t magic;
  gidx_t string_offset;
  gidx_t hash_offset;
  gidx_t hash_size;
  gidx_t module_offset;
  gidx_t otherconv_offset;
};

/* 1035 */
struct extra_entry_module
{
  gidx_t outname_offset;
  gidx_t dir_offset;
  gidx_t name_offset;
};

/* 1036 */
struct extra_entry
{
  gidx_t module_cnt;
  extra_entry_module module[];
};

/* 1038 */
struct module_entry
{
  gidx_t canonname_offset;
  gidx_t fromdir_offset;
  gidx_t fromname_offset;
  gidx_t todir_offset;
  gidx_t toname_offset;
  gidx_t extra_offset;
};

/* 1039 */
struct hash_entry
{
  gidx_t string_offset;
  gidx_t module_idx;
};

/* 1040 */
struct __attribute__((aligned(8))) builtin_map
{
  const char *name;
  __gconv_fct fct;
  __gconv_btowc_fct btowc_fct;
  int8_t min_needed_from;
  int8_t max_needed_from;
  int8_t min_needed_to;
  int8_t max_needed_to;
};

/* 1041 */
struct gconv_alias
{
  char *fromname;
  char *toname;
};

/* 1042 */
struct gconv_module
{
  const char *from_string;
  const char *to_string;
  int cost_hi;
  int cost_lo;
  const char *module_name;
  gconv_module *left;
  gconv_module *same;
  gconv_module *right;
};

/* 1043 */
struct path_elem
{
  const char *name;
  size_t len;
};

/* 1044 */
struct known_derivation
{
  const char *from;
  const char *to;
  __gconv_step *steps;
  size_t nsteps;
};

/* 1045 */
struct derivation_step
{
  const char *result_set;
  size_t result_set_len;
  int cost_lo;
  int cost_hi;
  gconv_module *code;
  derivation_step *last;
  derivation_step *next;
};

/* 1046 */
typedef void *iconv_t;

/* 1047 */
struct Elf64_Nhdr
{
  Elf64_Word n_namesz;
  Elf64_Word n_descsz;
  Elf64_Word n_type;
};

/* 1056 */
struct fmemopen_cookie_struct_0
{
  char *buffer;
  int mybuffer;
  int append;
  size_t size;
  off64_t pos;
  size_t maxpos;
};

/* 1057 */
typedef __locale_struct *__locale_t_0;

/* 1063 */
union querybuf_0
{
  HEADER hdr;
  unsigned __int8 buf[65536];
};

/* 1064 */
typedef int (*db_lookup_function_0)(nss_action **, const char *, const char *, void **);

/* 1065 */
typedef nss_status (*lookup_function_0)(uint32_t, int, netent *, char *, size_t, int *, int *);

/* 1066 */
typedef nss_status (*lookup_function_1)(const void *, socklen_t, int, hostent *, char *, size_t, int *, int *);

/* 1069 */
typedef nss_status (*lookup_function_2)(uid_t, passwd *, char *, size_t, int *);

/* 1070 */
typedef nss_status (*lookup_function_3)(gid_t, group *, char *, size_t, int *);

/* 1071 */
typedef const char *THOUSANDS_SEP_T_0;

/* 1072 */
typedef __locale_t_0 locale_t_0;

/* 1073 */
typedef nss_status (*lookup_function_4)(const char *, aliasent *, char *, size_t, int *);

/* 1074 */
typedef int (*lookup_function_5)(const ether_addr *, etherent *, char *, size_t, int *);

/* 1075 */
typedef nss_status (*lookup_function_6)(int, rpcent *, char *, size_t, int *);

/* 1076 */
typedef nss_status (*lookup_function_7)(const char *, rpcent *, char *, size_t, int *);

/* 1077 */
typedef nss_status (*lookup_function_8)(int, const char *, servent *, char *, size_t, int *);

/* 1078 */
typedef nss_status (*lookup_function_9)(const char *, const char *, servent *, char *, size_t, int *);

/* 1079 */
typedef nss_status (*lookup_function_10)(const char *, protoent *, char *, size_t, int *);

/* 1080 */
typedef nss_status (*lookup_function_11)(int, protoent *, char *, size_t, int *);

/* 1081 */
typedef nss_status (*lookup_function_12)(const char *, netent *, char *, size_t, int *, int *);

/* 1082 */
typedef nss_status (*lookup_function_13)(const char *, hostent *, char *, size_t, int *, int *);

/* 1083 */
typedef nss_status (*lookup_function_14)(const char *, int, hostent *, char *, size_t, int *, int *);

/* 1084 */
typedef nss_status (*lookup_function_15)(const char *, sgrp *, char *, size_t, int *);

/* 1085 */
typedef nss_status (*lookup_function_16)(const char *, spwd *, char *, size_t, int *);

/* 1086 */
typedef nss_status (*lookup_function_17)(const char *, passwd *, char *, size_t, int *);

/* 1087 */
typedef nss_status (*lookup_function_18)(const char *, group *, char *, size_t, int *);

/* 1089 */
struct __gconv_step_data_0
{
  unsigned __int8 *__outbuf;
  unsigned __int8 *__outbufend;
  int __flags;
  int __invocation_counter;
  int __internal_use;
  __mbstate_t *__statep;
  __mbstate_t __state;
};

/* 1090 */
struct _IO_iconv_t_0
{
  __gconv_step *step;
  __gconv_step_data_0 step_data;
};

/* 1091 */
struct link_map_0
{
  Elf64_Addr l_addr;
  char *l_name;
  Elf64_Dyn_0 *l_ld;
  link_map *l_next;
  link_map *l_prev;
  link_map *l_real;
  Lmid_t l_ns;
  libname_list *l_libname;
  Elf64_Dyn_0 *l_info[77];
  const Elf64_Phdr *l_phdr;
  Elf64_Addr l_entry;
  Elf64_Half l_phnum;
  Elf64_Half l_ldnum;
  r_scope_elem l_searchlist;
  r_scope_elem l_symbolic_searchlist;
  link_map *l_loader;
  r_found_version *l_versions;
  unsigned int l_nversions;
  Elf_Symndx l_nbuckets;
  Elf32_Word l_gnu_bitmask_idxbits;
  Elf32_Word l_gnu_shift;
  const Elf64_Addr *l_gnu_bitmask;
  union
  {
    const Elf32_Word *l_gnu_buckets;
    const Elf_Symndx *l_chain;
  };
  union
  {
    const Elf32_Word *l_gnu_chain_zero;
    const Elf_Symndx *l_buckets;
  };
  unsigned int l_direct_opencount;
  _BYTE gap31C[3];
  bool l_nodelete_active;
  bool l_nodelete_pending;
  unsigned int l_x86_feature_1_and;
  unsigned int l_x86_isa_1_needed;
  unsigned int l_1_needed;
  r_search_path_struct l_rpath_dirs;
  reloc_result *l_reloc_result;
  Elf64_Versym *l_versyms;
  const char *l_origin;
  Elf64_Addr l_map_start;
  Elf64_Addr l_map_end;
  Elf64_Addr l_text_end;
  r_scope_elem *l_scope_mem[4];
  size_t l_scope_max;
  r_scope_elem **l_scope;
  r_scope_elem *l_local_scope[2];
  r_file_id l_file_id;
  r_search_path_struct l_runpath_dirs;
  link_map **l_initfini;
  link_map_reldeps *l_reldeps;
  unsigned int l_reldepsmax;
  unsigned int l_used;
  Elf64_Word l_feature_1;
  Elf64_Word l_flags_1;
  Elf64_Word l_flags;
  int l_idx;
  link_map_machine l_mach;
  struct
  {
    const Elf64_Sym_0 *sym;
    int type_class;
    link_map *value;
    const Elf64_Sym_0 *ret;
  } l_lookup_cache;
  void *l_tls_initimage;
  size_t l_tls_initimage_size;
  size_t l_tls_blocksize;
  size_t l_tls_align;
  size_t l_tls_firstbyte_offset;
  ptrdiff_t l_tls_offset;
  size_t l_tls_modid;
  size_t l_tls_dtor_count;
  Elf64_Addr l_relro_addr;
  size_t l_relro_size;
  unsigned __int64 l_serial;
};

/* 1092 */
union pthread_attr_transparent
{
  pthread_attr_t external;
  pthread_attr internal;
};

/* 1093 */
struct __attribute__((aligned(8))) rtld_global_0
{
  link_namespaces _dl_ns[16];
  size_t _dl_nns;
  __rtld_lock_recursive_t _dl_load_lock;
  __rtld_lock_recursive_t _dl_load_write_lock;
  __rtld_lock_recursive_t _dl_load_tls_lock;
  unsigned __int64 _dl_load_adds;
  link_map *_dl_initfirst;
  link_map *_dl_profile_map;
  unsigned __int64 _dl_num_relocations;
  unsigned __int64 _dl_num_cache_relocations;
  r_search_path_elem *_dl_all_dirs;
  link_map _dl_rtld_map;
  auditstate _dl_rtld_auditstate[16];
  unsigned int _dl_x86_feature_1;
  dl_x86_feature_control _dl_x86_feature_control;
  Elf64_Word _dl_stack_flags;
  bool _dl_tls_dtv_gaps;
  size_t _dl_tls_max_dtv_idx;
  dtv_slotinfo_list *_dl_tls_dtv_slotinfo_list;
  size_t _dl_tls_static_nelem;
  size_t _dl_tls_static_used;
  size_t _dl_tls_static_optional;
  void *_dl_initial_dtv;
  size_t _dl_tls_generation;
  dl_scope_free_list *_dl_scope_free_list;
  list_t _dl_stack_used;
  list_t _dl_stack_user;
  list_t _dl_stack_cache;
  size_t _dl_stack_cache_actsize;
  uintptr_t _dl_in_flight_stack;
  int _dl_stack_cache_lock;
};

/* 1094 */
enum dl_x86_cet_control : __int32
{
  dl_x86_cet_control::cet_elf_property = 0x0,
  dl_x86_cet_control::cet_always_on = 0x1,
  dl_x86_cet_control::cet_always_off = 0x2,
  dl_x86_cet_control::cet_permissive = 0x3,
};

/* 1095 */
struct reloc_result_0
{
  Elf64_Addr addr;
  link_map *bound;
  unsigned int boundndx;
  uint32_t enterexit;
  unsigned int flags;
  unsigned int init;
};

/* 1096 */
struct dl_find_object_0
{
  unsigned __int64 dlfo_flags;
  void *dlfo_map_start;
  void *dlfo_map_end;
  link_map *dlfo_link_map;
  void *dlfo_eh_frame;
  unsigned __int64 __dflo_reserved[7];
};

/* 1097 */
enum cpuid_register_index : __int32
{
  cpuid_register_index::cpuid_register_index_eax = 0x0,
  cpuid_register_index::cpuid_register_index_ebx = 0x1,
  cpuid_register_index::cpuid_register_index_ecx = 0x2,
  cpuid_register_index::cpuid_register_index_edx = 0x3,
};

/* 1098 */
enum rseq_cs_flags_bit : __int32
{
  rseq_cs_flags_bit::RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0x0,
  rseq_cs_flags_bit::RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 0x1,
  rseq_cs_flags_bit::RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 0x2,
};

/* 1099 */
struct link_map_1
{
  Elf64_Addr l_addr;
  char *l_name;
  Elf64_Dyn_0 *l_ld;
  link_map *l_next;
  link_map *l_prev;
  link_map *l_real;
  Lmid_t l_ns;
  libname_list *l_libname;
  Elf64_Dyn_0 *l_info[77];
  const Elf64_Phdr *l_phdr;
  Elf64_Addr l_entry;
  Elf64_Half l_phnum;
  Elf64_Half l_ldnum;
  r_scope_elem l_searchlist;
  r_scope_elem l_symbolic_searchlist;
  link_map *l_loader;
  r_found_version *l_versions;
  unsigned int l_nversions;
  Elf_Symndx l_nbuckets;
  Elf32_Word l_gnu_bitmask_idxbits;
  Elf32_Word l_gnu_shift;
  const Elf64_Addr *l_gnu_bitmask;
  union
  {
    const Elf32_Word *l_gnu_buckets;
    const Elf_Symndx *l_chain;
  };
  union
  {
    const Elf32_Word *l_gnu_chain_zero;
    const Elf_Symndx *l_buckets;
  };
  unsigned int l_direct_opencount;
  _BYTE gap31C[3];
  bool l_nodelete_active;
  bool l_nodelete_pending;
  unsigned int l_x86_feature_1_and;
  unsigned int l_x86_isa_1_needed;
  unsigned int l_1_needed;
  r_search_path_struct l_rpath_dirs;
  reloc_result *l_reloc_result;
  Elf64_Versym *l_versyms;
  const char *l_origin;
  Elf64_Addr l_map_start;
  Elf64_Addr l_map_end;
  Elf64_Addr l_text_end;
  r_scope_elem *l_scope_mem[4];
  size_t l_scope_max;
  r_scope_elem **l_scope;
  r_scope_elem *l_local_scope[2];
  r_file_id l_file_id;
  r_search_path_struct l_runpath_dirs;
  link_map **l_initfini;
  link_map_reldeps *l_reldeps;
  unsigned int l_reldepsmax;
  unsigned int l_used;
  Elf64_Word l_feature_1;
  Elf64_Word l_flags_1;
  Elf64_Word l_flags;
  int l_idx;
  link_map_machine l_mach;
  struct
  {
    const Elf64_Sym_0 *sym;
    int type_class;
    link_map *value;
    const Elf64_Sym_0 *ret;
  } l_lookup_cache;
  void *l_tls_initimage;
  size_t l_tls_initimage_size;
  size_t l_tls_blocksize;
  size_t l_tls_align;
  size_t l_tls_firstbyte_offset;
  ptrdiff_t l_tls_offset;
  size_t l_tls_modid;
  size_t l_tls_dtor_count;
  Elf64_Addr l_relro_addr;
  size_t l_relro_size;
  unsigned __int64 l_serial;
};

/* 1100 */
typedef link_map *lookup_t_0;

/* 1101 */
struct __attribute__((aligned(8))) flock64
{
  __int16 l_type;
  __int16 l_whence;
  __off64_t l_start;
  __off64_t l_len;
  __pid_t l_pid;
};

/* 1102 */
enum __socket_type : __int32
{
  __socket_type::SOCK_STREAM = 0x1,
  __socket_type::SOCK_DGRAM = 0x2,
  __socket_type::SOCK_RAW = 0x3,
  __socket_type::SOCK_RDM = 0x4,
  __socket_type::SOCK_SEQPACKET = 0x5,
  __socket_type::SOCK_DCCP = 0x6,
  __socket_type::SOCK_PACKET = 0xA,
  __socket_type::SOCK_CLOEXEC = 0x80000,
  __socket_type::SOCK_NONBLOCK = 0x800,
};

/* 1103 */
enum __ns_sect : __int32
{
  __ns_sect::ns_s_qd = 0x0,
  __ns_sect::ns_s_zn = 0x0,
  __ns_sect::ns_s_an = 0x1,
  __ns_sect::ns_s_pr = 0x1,
  __ns_sect::ns_s_ns = 0x2,
  __ns_sect::ns_s_ud = 0x2,
  __ns_sect::ns_s_ar = 0x3,
  __ns_sect::ns_s_max = 0x4,
};

/* 1104 */
struct _IO_wide_data_0
{
  wchar_t *_IO_read_ptr;
  wchar_t *_IO_read_end;
  wchar_t *_IO_read_base;
  wchar_t *_IO_write_base;
  wchar_t *_IO_write_ptr;
  wchar_t *_IO_write_end;
  wchar_t *_IO_buf_base;
  wchar_t *_IO_buf_end;
  wchar_t *_IO_save_base;
  wchar_t *_IO_backup_base;
  wchar_t *_IO_save_end;
  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  _IO_codecvt _codecvt;
  wchar_t _shortbuf[1];
  const _IO_jump_t *_wide_vtable;
};

/* 1105 */
typedef _IO_FILE FILE_0;

/* 1106 */
typedef bool_t (*xdr_sizeof::dummyfunc3)(XDR *, int32_t *);

/* 1107 */
typedef bool_t (*xdr_sizeof::dummyfunc2)(XDR *, caddr_t, u_int);

/* 1108 */
typedef bool_t (*xdr_sizeof::dummyfunc1)(XDR *, __int64 *);

/* 1109 */
struct xdr_ops_0
{
  bool_t (*x_getlong)(XDR *, __int64 *);
  bool_t (*x_putlong)(XDR *, const __int64 *);
  bool_t (*x_getbytes)(XDR *, caddr_t, u_int);
  bool_t (*x_putbytes)(XDR *, const char *, u_int);
  u_int (*x_getpostn)(const XDR *);
  bool_t (*x_setpostn)(XDR *, u_int);
  int32_t *(*x_inline)(XDR *, u_int);
  void (*x_destroy)(XDR *);
  bool_t (*x_getint32)(XDR *, int32_t *);
  bool_t (*x_putint32)(XDR *, const int32_t *);
};

/* 1110 */
struct rpc_thread_variables_0
{
  fd_set svc_fdset_s;
  rpc_createerr rpc_createerr_s;
  pollfd *svc_pollfd_s;
  int svc_max_pollfd_s;
  char *clnt_perr_buf_s;
  clntraw_private_s *clntraw_private_s;
  callrpc_private_s *callrpc_private_s;
  key_call_private *key_call_private_s;
  cache_entry *authdes_cache_s;
  int *authdes_lru_s;
  SVCXPRT **svc_xports_s;
  svc_callout *svc_head_s;
  svcraw_private_s *svcraw_private_s;
  proglst_ *svcsimple_proglst_s;
  SVCXPRT *svcsimple_transp_s;
};

/* 1111 */
struct xdr_ops_1
{
  bool_t (*x_getlong)(XDR *, __int64 *);
  bool_t (*x_putlong)(XDR *, const __int64 *);
  bool_t (*x_getbytes)(XDR *, caddr_t, u_int);
  bool_t (*x_putbytes)(XDR *, const char *, u_int);
  u_int (*x_getpostn)(const XDR *);
  bool_t (*x_setpostn)(XDR *, u_int);
  int32_t *(*x_inline)(XDR *, u_int);
  void (*x_destroy)(XDR *);
  bool_t (*x_getint32)(XDR *, int32_t *);
  bool_t (*x_putint32)(XDR *, const int32_t *);
};

/* 1112 */
typedef __intptr_t intptr_t_0;

/* 1113 */
struct cmessage
{
  cmsghdr cmsg;
  ucred cmcred;
  char dummy[12];
};

/* 1114 */
struct ct_data_0
{
  int ct_sock;
  bool_t ct_closeit;
  timeval ct_wait;
  bool_t ct_waitset;
  sockaddr_un ct_addr;
  rpc_err ct_error;
  char ct_mcall[24];
  u_int ct_mpos;
  XDR ct_xdrs;
};

/* 1115 */
typedef __fpos_t fpos_t;

/* 1116 */
struct parser_data_0
{
  hostent_data entdata;
  char linebuffer[];
};

/* 1117 */
struct __attribute__((aligned(8))) hconf
{
  int initialized;
  int unused1;
  int unused2[4];
  int num_trimdomains;
  const char *trimdomain[4];
  unsigned int flags;
};

/* 1118 */
enum nss_database_default : __int32
{
  nss_database_default::nss_database_default_defconfig = 0x0,
  nss_database_default::nss_database_default_compat = 0x1,
  nss_database_default::nss_database_default_dns = 0x2,
  nss_database_default::nss_database_default_files = 0x3,
  nss_database_default::nss_database_default_nis = 0x4,
  nss_database_default::nss_database_default_nis_nisplus = 0x5,
  nss_database_default::nss_database_default_none = 0x6,
  nss_database_default::NSS_DATABASE_DEFAULT_COUNT = 0x7,
};

/* 1119 */
typedef nss_action *nss_action_list_0;

/* 1120 */
enum nss_module_state : __int32
{
  nss_module_state::nss_module_uninitialized = 0x0,
  nss_module_state::nss_module_loaded = 0x1,
  nss_module_state::nss_module_failed = 0x2,
};

/* 1121 */
struct resolv_conf_0
{
  size_t __refcount;
  const sockaddr **nameserver_list;
  size_t nameserver_list_size;
  const char *const *search_list;
  size_t search_list_size;
  const resolv_sortlist_entry *sort_list;
  size_t sort_list_size;
  unsigned int options;
  unsigned int retrans;
  unsigned int retry;
  unsigned int ndots;
};

/* 1122 */
struct __netgrent_0
{
  enum : __int32
  {
    triple_val = 0x0,
    group_val = 0x1,
  } type;
  union
  {
    struct
    {
      const char *host;
      const char *user;
      const char *domain;
    } triple;
    const char *group;
  } val;
  char *data;
  size_t data_size;
  union
  {
    char *cursor;
    unsigned __int64 position;
  };
  int first;
  name_list *known_groups;
  name_list *needed_groups;
  nss_action *nip;
};

/* 1123 */
struct gaicb_0
{
  const char *ar_name;
  const char *ar_service;
  const addrinfo *ar_request;
  addrinfo *ar_result;
  int __return;
  int __glibc_reserved[5];
};

/* 1124 */
struct requestlist_0
{
  int running;
  requestlist *next;
  gaicb *gaicbp;
  waitlist *waiting;
};

/* 1125 */
struct requestlist_1
{
  int running;
  requestlist *next;
  gaicb *gaicbp;
  waitlist *waiting;
};

/* 1126 */
struct gaiinit
{
  int gai_threads;
  int gai_num;
  int gai_locks;
  int gai_usedba;
  int gai_debug;
  int gai_numusers;
  int gai_idle_time;
  int gai_reserved;
};

/* 1127 */
struct requestlist_2
{
  int running;
  requestlist *next;
  gaicb *gaicbp;
  waitlist *waiting;
};

/* 1128 */
enum __ns_rcode : __int32
{
  __ns_rcode::ns_r_noerror = 0x0,
  __ns_rcode::ns_r_formerr = 0x1,
  __ns_rcode::ns_r_servfail = 0x2,
  __ns_rcode::ns_r_nxdomain = 0x3,
  __ns_rcode::ns_r_notimpl = 0x4,
  __ns_rcode::ns_r_refused = 0x5,
  __ns_rcode::ns_r_yxdomain = 0x6,
  __ns_rcode::ns_r_yxrrset = 0x7,
  __ns_rcode::ns_r_nxrrset = 0x8,
  __ns_rcode::ns_r_notauth = 0x9,
  __ns_rcode::ns_r_notzone = 0xA,
  __ns_rcode::ns_r_max = 0xB,
  __ns_rcode::ns_r_badvers = 0x10,
  __ns_rcode::ns_r_badsig = 0x10,
  __ns_rcode::ns_r_badkey = 0x11,
  __ns_rcode::ns_r_badtime = 0x12,
};

/* 1129 */
enum __ns_type : __int32
{
  __ns_type::ns_t_invalid = 0x0,
  __ns_type::ns_t_a = 0x1,
  __ns_type::ns_t_ns = 0x2,
  __ns_type::ns_t_md = 0x3,
  __ns_type::ns_t_mf = 0x4,
  __ns_type::ns_t_cname = 0x5,
  __ns_type::ns_t_soa = 0x6,
  __ns_type::ns_t_mb = 0x7,
  __ns_type::ns_t_mg = 0x8,
  __ns_type::ns_t_mr = 0x9,
  __ns_type::ns_t_null = 0xA,
  __ns_type::ns_t_wks = 0xB,
  __ns_type::ns_t_ptr = 0xC,
  __ns_type::ns_t_hinfo = 0xD,
  __ns_type::ns_t_minfo = 0xE,
  __ns_type::ns_t_mx = 0xF,
  __ns_type::ns_t_txt = 0x10,
  __ns_type::ns_t_rp = 0x11,
  __ns_type::ns_t_afsdb = 0x12,
  __ns_type::ns_t_x25 = 0x13,
  __ns_type::ns_t_isdn = 0x14,
  __ns_type::ns_t_rt = 0x15,
  __ns_type::ns_t_nsap = 0x16,
  __ns_type::ns_t_nsap_ptr = 0x17,
  __ns_type::ns_t_sig = 0x18,
  __ns_type::ns_t_key = 0x19,
  __ns_type::ns_t_px = 0x1A,
  __ns_type::ns_t_gpos = 0x1B,
  __ns_type::ns_t_aaaa = 0x1C,
  __ns_type::ns_t_loc = 0x1D,
  __ns_type::ns_t_nxt = 0x1E,
  __ns_type::ns_t_eid = 0x1F,
  __ns_type::ns_t_nimloc = 0x20,
  __ns_type::ns_t_srv = 0x21,
  __ns_type::ns_t_atma = 0x22,
  __ns_type::ns_t_naptr = 0x23,
  __ns_type::ns_t_kx = 0x24,
  __ns_type::ns_t_cert = 0x25,
  __ns_type::ns_t_a6 = 0x26,
  __ns_type::ns_t_dname = 0x27,
  __ns_type::ns_t_sink = 0x28,
  __ns_type::ns_t_opt = 0x29,
  __ns_type::ns_t_apl = 0x2A,
  __ns_type::ns_t_ds = 0x2B,
  __ns_type::ns_t_sshfp = 0x2C,
  __ns_type::ns_t_ipseckey = 0x2D,
  __ns_type::ns_t_rrsig = 0x2E,
  __ns_type::ns_t_nsec = 0x2F,
  __ns_type::ns_t_dnskey = 0x30,
  __ns_type::ns_t_dhcid = 0x31,
  __ns_type::ns_t_nsec3 = 0x32,
  __ns_type::ns_t_nsec3param = 0x33,
  __ns_type::ns_t_tlsa = 0x34,
  __ns_type::ns_t_smimea = 0x35,
  __ns_type::ns_t_hip = 0x37,
  __ns_type::ns_t_ninfo = 0x38,
  __ns_type::ns_t_rkey = 0x39,
  __ns_type::ns_t_talink = 0x3A,
  __ns_type::ns_t_cds = 0x3B,
  __ns_type::ns_t_cdnskey = 0x3C,
  __ns_type::ns_t_openpgpkey = 0x3D,
  __ns_type::ns_t_csync = 0x3E,
  __ns_type::ns_t_spf = 0x63,
  __ns_type::ns_t_uinfo = 0x64,
  __ns_type::ns_t_uid = 0x65,
  __ns_type::ns_t_gid = 0x66,
  __ns_type::ns_t_unspec = 0x67,
  __ns_type::ns_t_nid = 0x68,
  __ns_type::ns_t_l32 = 0x69,
  __ns_type::ns_t_l64 = 0x6A,
  __ns_type::ns_t_lp = 0x6B,
  __ns_type::ns_t_eui48 = 0x6C,
  __ns_type::ns_t_eui64 = 0x6D,
  __ns_type::ns_t_tkey = 0xF9,
  __ns_type::ns_t_tsig = 0xFA,
  __ns_type::ns_t_ixfr = 0xFB,
  __ns_type::ns_t_axfr = 0xFC,
  __ns_type::ns_t_mailb = 0xFD,
  __ns_type::ns_t_maila = 0xFE,
  __ns_type::ns_t_any = 0xFF,
  __ns_type::ns_t_uri = 0x100,
  __ns_type::ns_t_caa = 0x101,
  __ns_type::ns_t_avc = 0x102,
  __ns_type::ns_t_ta = 0x8000,
  __ns_type::ns_t_dlv = 0x8001,
  __ns_type::ns_t_max = 0x10000,
};

/* 1130 */
enum __ns_opcode : __int32
{
  __ns_opcode::ns_o_query = 0x0,
  __ns_opcode::ns_o_iquery = 0x1,
  __ns_opcode::ns_o_status = 0x2,
  __ns_opcode::ns_o_notify = 0x4,
  __ns_opcode::ns_o_update = 0x5,
  __ns_opcode::ns_o_max = 0x6,
};

/* 1131 */
enum parse_cbs : __int32
{
  parse_cbs::CB_none = 0x0,
  parse_cbs::CB_arg_trimdomain_list = 0x1,
  parse_cbs::CB_arg_bool = 0x2,
};

/* 1132 */
union inet_aton_end::iaddr
{
  uint8_t bytes[4];
  uint32_t word;
};

/* 1133 */
enum __ns_class : __int32
{
  __ns_class::ns_c_invalid = 0x0,
  __ns_class::ns_c_in = 0x1,
  __ns_class::ns_c_2 = 0x2,
  __ns_class::ns_c_chaos = 0x3,
  __ns_class::ns_c_hs = 0x4,
  __ns_class::ns_c_none = 0xFE,
  __ns_class::ns_c_any = 0xFF,
  __ns_class::ns_c_max = 0x10000,
};

/* 1134 */
typedef unsigned __int64 uint_fast16_t;

/* 1135 */
struct ifconf
{
  int ifc_len;
  union
  {
    __caddr_t ifcu_buf;
    ifreq *ifcu_req;
  } ifc_ifcu;
};

/* 1136 */
struct __check_native::req
{
  nlmsghdr nlh;
  rtgenmsg g;
  char pad[3];
};

/* 1137 */
struct sockaddr_nl
{
  __kernel_sa_family_t nl_family;
  unsigned __int16 nl_pad;
  __u32 nl_pid;
  __u32 nl_groups;
};

/* 1138 */
struct make_request::req
{
  nlmsghdr nlh;
  rtgenmsg g;
  char pad[3];
};

/* 1139 */
enum idna_name_classification : __int32
{
  idna_name_classification::idna_name_ascii = 0x0,
  idna_name_classification::idna_name_nonascii = 0x1,
  idna_name_classification::idna_name_nonascii_backslash = 0x2,
  idna_name_classification::idna_name_encoding_error = 0x3,
  idna_name_classification::idna_name_memory_error = 0x4,
  idna_name_classification::idna_name_error = 0x5,
};

/* 1140 */
typedef __uintmax_t uintmax_t;

/* 1141 */
struct __attribute__((aligned(4))) __netlink_sendreq::req
{
  nlmsghdr nlh;
  rtgenmsg g;
};

/* 1142 */
struct __attribute__((aligned(8))) netlink_res_0
{
  netlink_res *next;
  nlmsghdr *nlh;
  size_t size;
  uint32_t seq;
};

/* 1143 */
struct __jmp_buf_tag_0
{
  __jmp_buf __jmpbuf;
  int __mask_was_saved;
  __jmpbuf_arch_t __saved_mask;
};

/* 1144 */
struct argp_state_0
{
  const argp *root_argp;
  int argc;
  char **argv;
  int next;
  unsigned int flags;
  unsigned int arg_num;
  int quoted;
  void *input;
  void **child_inputs;
  void *hook;
  char *name;
  FILE *err_stream;
  FILE *out_stream;
  void *pstate;
};

/* 1145 */
struct group_0
{
  argp_parser_t parser;
  const argp *argp;
  char *short_end;
  unsigned int args_processed;
  group *parent;
  unsigned int parent_index;
  void *input;
  void **child_inputs;
  void *hook;
};

/* 1146 */
struct uparams
{
  int dup_args;
  int dup_args_note;
  int short_opt_col;
  int long_opt_col;
  int doc_opt_col;
  int opt_doc_col;
  int header_col;
  int usage_indent;
  int rmargin;
};

/* 1147 */
struct __attribute__((aligned(8))) flock
{
  __int16 l_type;
  __int16 l_whence;
  __off_t l_start;
  __off_t l_len;
  __pid_t l_pid;
};

/* 1148 */
struct prof_info
{
  unsigned int num_regions;
  region *region;
  region *last;
  region *overflow;
  itimerval saved_timer;
  sigaction saved_action;
};

/* 1149 */
struct write_hist::real_gmon_hist_hdr
{
  char *low_pc;
  char *high_pc;
  int32_t hist_size;
  int32_t prof_rate;
  char dimen[15];
  char dimen_abbrev;
};

/* 1150 */
struct __attribute__((aligned(8))) write_call_graph::arc
{
  char *frompc;
  char *selfpc;
  int32_t count;
};

/* 1151 */
struct write_gmon::real_gmon_hdr
{
  char cookie[4];
  int32_t version;
  char spare[12];
};

/* 1152 */
struct __attribute__((aligned(8))) mmsghdr_0
{
  msghdr msg_hdr;
  unsigned int msg_len;
};

/* 1153 */
enum malloc_thp_mode_t : __int32
{
  malloc_thp_mode_t::malloc_thp_mode_always = 0x0,
  malloc_thp_mode_t::malloc_thp_mode_madvise = 0x1,
  malloc_thp_mode_t::malloc_thp_mode_never = 0x2,
  malloc_thp_mode_t::malloc_thp_mode_not_supported = 0x3,
};

/* 1154 */
typedef const node_t *const_node;

/* 1155 */
struct hsearch_data_0
{
  _ENTRY *table;
  unsigned int size;
  unsigned int filled;
};

/* 1156 */
struct __kernel_termios
{
  tcflag_t c_iflag;
  tcflag_t c_oflag;
  tcflag_t c_cflag;
  tcflag_t c_lflag;
  cc_t c_line;
  cc_t c_cc[19];
};

/* 1157 */
struct f_owner_ex
{
  __pid_type type;
  __pid_t pid;
};

/* 1158 */
struct original_statx
{
  __uint32_t stx_mask;
  __uint32_t stx_blksize;
  __uint64_t stx_attributes;
  __uint32_t stx_nlink;
  __uint32_t stx_uid;
  __uint32_t stx_gid;
  __uint16_t stx_mode;
  __uint16_t __statx_pad1[1];
  __uint64_t stx_ino;
  __uint64_t stx_size;
  __uint64_t stx_blocks;
  __uint64_t stx_attributes_mask;
  statx_timestamp stx_atime;
  statx_timestamp stx_btime;
  statx_timestamp stx_ctime;
  statx_timestamp stx_mtime;
  __uint32_t stx_rdev_major;
  __uint32_t stx_rdev_minor;
  __uint32_t stx_dev_major;
  __uint32_t stx_dev_minor;
  __uint64_t __statx_pad2[14];
};

/* 1159 */
enum parse_param::action : __int32
{
  parse_param::action::ACT_NONE = 0x0,
  parse_param::action::ACT_RP_SHORT_LEFT = 0x23,
  parse_param::action::ACT_RP_LONG_LEFT = 0x4C,
  parse_param::action::ACT_RP_SHORT_RIGHT = 0x25,
  parse_param::action::ACT_RP_LONG_RIGHT = 0x52,
  parse_param::action::ACT_NULL_ERROR = 0x3F,
  parse_param::action::ACT_NULL_SUBST = 0x2D,
  parse_param::action::ACT_NONNULL_SUBST = 0x2B,
  parse_param::action::ACT_NULL_ASSIGN = 0x3D,
};

/* 1160 */
typedef __int64 int_fast32_t;

/* 1161 */
typedef nss_status (*get_function)(group *, char *, size_t, int *);

/* 1162 */
typedef nss_status (*end_function)(void);

/* 1163 */
typedef nss_status (*set_function)(void);

/* 1164 */
typedef nss_status (*initgroups_dyn_function)(const char *, gid_t, __int64 *, __int64 *, gid_t **, __int64, int *);

/* 1165 */
struct __strptime_internal::__strptime_state
{
  _BYTE gap0[2];
  char week_no;
  char century;
  int era_cnt;
};

/* 1166 */
enum __strptime_internal::ptime_locale_status : __int32
{
  __strptime_internal::ptime_locale_status::not = 0x0,
  __strptime_internal::ptime_locale_status::loc = 0x1,
  __strptime_internal::ptime_locale_status::raw = 0x2,
};

/* 1167 */
struct tzhead
{
  char tzh_magic[4];
  char tzh_version[1];
  char tzh_reserved[15];
  char tzh_ttisutcnt[4];
  char tzh_ttisstdcnt[4];
  char tzh_leapcnt[4];
  char tzh_timecnt[4];
  char tzh_typecnt[4];
  char tzh_charcnt[4];
};

/* 1168 */
union ieee854_float128
{
  _Float128 d;
  struct
  {
    _BYTE gap0[16];
  } ieee;
  struct
  {
    _BYTE gap0[16];
  } ieee_nan;
};

/* 1169 */
typedef unsigned __int64 UDItype;

/* 1170 */
struct __attribute__((aligned(8))) _IO_marker_0
{
  _IO_marker *_next;
  FILE *_sbuf;
  int _pos;
};

/* 1171 */
enum coll_sort_rule : __int32
{
  coll_sort_rule::illegal_0__ = 0x0,
  coll_sort_rule::sort_forward = 0x1,
  coll_sort_rule::sort_backward = 0x2,
  coll_sort_rule::illegal_3__ = 0x3,
  coll_sort_rule::sort_position = 0x4,
  coll_sort_rule::sort_forward_position = 0x5,
  coll_sort_rule::sort_backward_position = 0x6,
  coll_sort_rule::sort_mask = 0x7,
};

/* 1172 */
union ieee754_float
{
  float f;
  struct
  {
    _BYTE gap0[4];
  } ieee;
  struct
  {
    _BYTE gap0[4];
  } ieee_nan;
};

/* 1173 */
union ieee854_long_double
{
  long double d;
  struct
  {
    _BYTE gap0[12];
  } ieee;
  struct
  {
    _BYTE gap0[12];
  } ieee_nan;
};

/* 1174 */
struct __v16qi
{
  char body[16];
};

/* 1175 */
typedef void ____libc_subfreeres_hook_function_t(void);

/* 1176 */
struct malloc_par
{
  unsigned __int64 trim_threshold;
  size_t top_pad;
  size_t mmap_threshold;
  size_t arena_test;
  size_t arena_max;
  size_t thp_pagesize;
  size_t hp_pagesize;
  int hp_flags;
  int n_mmaps;
  int n_mmaps_max;
  int max_n_mmaps;
  int no_dyn_threshold;
  size_t mmapped_mem;
  size_t max_mmapped_mem;
  char *sbrk_base;
  size_t tcache_bins;
  size_t tcache_max_bytes;
  size_t tcache_count;
  size_t tcache_unsorted_limit;
};

/* 1177 */
typedef malloc_chunk *mbinptr;

/* 1178 */
struct mallinfo
{
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
};

/* 1179 */
struct async_waitlist_0
{
  unsigned int counter;
  sigevent sigev;
  waitlist list[];
};

/* 1180 */
struct requestlist_3
{
  int running;
  requestlist *last_fd;
  requestlist *next_fd;
  requestlist *next_prio;
  requestlist *next_run;
  aiocb_union *aiocbp;
  waitlist *waiting;
};

/* 1181 */
struct requestlist_4
{
  int running;
  requestlist *last_fd;
  requestlist *next_fd;
  requestlist *next_prio;
  requestlist *next_run;
  aiocb_union *aiocbp;
  waitlist *waiting;
};

/* 1182 */
struct waitlist_1
{
  waitlist *next;
  int *result;
  volatile unsigned int *counterp;
  sigevent *sigevp;
};

/* 1183 */
struct search_sem
{
  dev_t dev;
  ino_t ino;
  int refcnt;
  sem_t *sem;
  char name[256];
};

/* 1184 */
struct mutex_config
{
  int spin_count;
};

/* 1185 */
struct __attribute__((aligned(8))) pthread_attr_extension_0
{
  cpu_set_t *cpuset;
  size_t cpusetsize;
  sigset_t sigmask;
  bool sigmask_set;
};

/* 1186 */
struct dtv_0
{
  dtv dtv[134217727];
};

/* 1187 */
struct pthread_key_data_level2
{
  pthread_key_data data[32];
};

/* 1188 */
enum rseq_cpu_id_state : __int32
{
  rseq_cpu_id_state::RSEQ_CPU_ID_UNINITIALIZED = 0xFFFFFFFF,
  rseq_cpu_id_state::RSEQ_CPU_ID_REGISTRATION_FAILED = 0xFFFFFFFE,
};

/* 1189 */
struct elision_config
{
  int skip_lock_busy;
  int skip_lock_internal_abort;
  int retry_try_xbegin;
  int skip_trylock_internal_abort;
};

/* 1190 */
enum dl_action_result_errstring_source : __int32
{
  dl_action_result_errstring_source::dl_action_result_errstring_constant = 0x0,
  dl_action_result_errstring_source::dl_action_result_errstring_rtld = 0x1,
  dl_action_result_errstring_source::dl_action_result_errstring_local = 0x2,
};

/* 1191 */
struct _IO_FILE_plus_0
{
  FILE file;
  const _IO_jump_t *vtable;
};

/* 1192 */
typedef fmemopen_cookie_struct_0 fmemopen_cookie_t_0;

/* 1193 */
struct __obstack_vprintf_internal::obstack_FILE
{
  _IO_obstack_file ofile;
};

/* 1194 */
enum __codecvt_result : __int32
{
  __codecvt_result::__codecvt_ok = 0x0,
  __codecvt_result::__codecvt_partial = 0x1,
  __codecvt_result::__codecvt_error = 0x2,
  __codecvt_result::__codecvt_noconv = 0x3,
};

/* 1195 */
typedef _IO_FILE_0 __FILE_0;

/* 1196 */
struct helper_file
{
  _IO_FILE_plus _f;
  _IO_wide_data _wide_data;
  FILE *_put_stream;
  _IO_lock_t lock;
};

/* 1197 */
struct helper_file_0
{
  _IO_FILE_plus _f;
  FILE *_put_stream;
  _IO_lock_t lock;
};

/* 1198 */
typedef ptrdiff_t idx_t;

/* 1199 */
struct lldiv_t
{
  __int64 quot;
  __int64 rem;
};

/* 1200 */
struct ldiv_t
{
  __int64 quot;
  __int64 rem;
};

/* 1201 */
struct div_t
{
  int quot;
  int rem;
};

/* 1202 */
typedef void ____libc_atexit_hook_function_t(void);

/* 1203 */
struct __libc_lock_recursive_t
{
  int lock;
  int cnt;
  void *owner;
};

/* 1204 */
struct kernel_sigaction
{
  __sighandler_t k_sa_handler;
  unsigned __int64 sa_flags;
  void (*sa_restorer)(void);
  sigset_t sa_mask;
};

/* 1205 */
union ieee854_float128_shape_type
{
  _Float128 value;
  struct
  {
    uint64_t lsw;
    uint64_t msw;
  } parts64;
  struct
  {
    uint32_t w3;
    uint32_t w2;
    uint32_t w1;
    uint32_t w0;
  } parts32;
};

/* 1206 */
union ieee_float_shape_type
{
  float value;
  uint32_t word;
};

/* 1207 */
union ieee_double_shape_type
{
  double value;
  struct
  {
    uint32_t lsw;
    uint32_t msw;
  } parts;
  uint64_t word;
};

/* 1208 */
union ieee_long_double_shape_type
{
  long double value;
  struct __attribute__((aligned(16)))
  {
    uint32_t lsw;
    uint32_t msw;
  } parts;
};

/* 1209 */
typedef int yy_state_fast_t;

/* 1210 */
struct parse_args_0
{
  const char *cp;
  expression *res;
};

/* 1211 */
struct loaded_domain_0
{
  const char *data;
  int use_mmap;
  size_t mmap_size;
  int must_swap;
  void *malloced;
  nls_uint32 nstrings;
  const string_desc *orig_tab;
  const string_desc *trans_tab;
  nls_uint32 n_sysdep_strings;
  const sysdep_string_desc *orig_sysdep_tab;
  const sysdep_string_desc *trans_sysdep_tab;
  nls_uint32 hash_size;
  const nls_uint32 *hash_tab;
  int must_swap_hash_tab;
  converted_domain *conversions;
  size_t nconversions;
  __libc_rwlock_t conversions_lock;
  const expression *plural;
  unsigned __int64 nplurals;
};

/* 1212 */
struct __gconv_step_0
{
  __gconv_loaded_object *__shlib_handle;
  const char *__modname;
  int __counter;
  char *__from_name;
  char *__to_name;
  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;
  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;
  int __stateful;
  void *__data;
};

/* 1213 */
typedef void (*dl_init_t)(int, char **, char **);

/* 1214 */
struct LONG_DOUBLE_16
{
  _TBYTE value;
  char padding[6];
};

